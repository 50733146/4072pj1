<h1>About</h1>
<p>專題題目: </p>
<p>強化學習在機電系統設計與控制中之應用 </p>
<p>Application of reinforcement learning in design and control of mechatronic systems</p>
<p>討論區: <a href="https://github.com/mdecourse/4072pj1/discussions">https://github.com/mdecourse/4072pj1/discussions</a></p>
<p>組員:</p>
<p style="padding-left: 30px;">40723110</p>
<p style="padding-left: 30px;">40723115</p>
<p style="padding-left: 30px;">40723138</p>
<p style="padding-left: 30px;">40723148</p>
<p style="padding-left: 30px;">40723150</p>
<h2>專題定位</h2>
<p>2021/01/08</p>
<p style="padding-left: 30px;">Adagrad: <a href="/downloads/2011_Adaptive Subgradient Methods for Online Learning and Stochastic Optimization.pdf">2011_Adaptive Subgradient Methods for Online Learning and Stochastic Optimization.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/2012_ADADELTA AN ADAPTIVE LEARNING RATE METHOD.pdf">2012_ADADELTA AN ADAPTIVE LEARNING RATE METHOD.pdf</a></p>
<p style="padding-left: 30px;">Adam: <a href="/downloads/2015_ADAM A METHOD  FORSTOCHASTICOPTIMIZATION.pdf">2015_ADAM A METHOD FORSTOCHASTICOPTIMIZATION.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/2017_An overview of gradient descent optimizationalgorithms.pdf">2017_An overview of gradient descent optimizationalgorithms.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/2018_A Comparative Analysis of Gradient Descent-Based Optimization Algorithms on Convolutional Neural Networks.pdf">2018_A Comparative Analysis of Gradient Descent-Based Optimization Algorithms on Convolutional Neural Networks.pdf</a></p>
<p style="padding-left: 30px;">第一組的理論與程式應用到第三組平面機構合成:</p>
<p style="padding-left: 30px;"><a href="/downloads/2015_Dimensional synthesis of mechanical linkages usingartificial neural networks and Fourier descriptors.pdf">2015_Dimensional synthesis of mechanical linkages usingartificial neural networks and Fourier descriptors.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/2017_Four-Bar Linkage Synthesis Using Non-ConvexOptimization.pdf">2017_Four-Bar Linkage Synthesis Using Non-ConvexOptimization.pdf</a></p>
<p style="padding-left: 30px;"><a href="/downloads/2018_Synthesis of a novel planar linkage to visit up to eight poses.pdf">2018_Synthesis of a novel planar linkage to visit up to eight poses.pdf</a></p>
<p></p>
<p>利用 <a href="https://cyberbotics.com/">Webots</a> 與 <a href="https://github.com/mdecourse/deepbots,">https://github.com/mdecourse/deepbots,</a> 透過 <a href="https://github.com/mdecourse/deepbots-tutorials">https://github.com/mdecourse/deepbots-tutorials</a> 與 <a href="https://github.com/mdecourse/deepworlds">https://github.com/mdecourse/deepworlds</a> 進一步了解 deepbots 如何應用在 Webots 中的受控系統.</p>
<p>專題目的在探討與 <a href="http://mde.tw/airhockey">http://mde.tw/airhockey</a> (<a href="https://github.com/mdecourse/airhockey">https://github.com/mdecourse/airhockey </a>)中虛實整合系統設計與控制有關的機器學習應用.</p>
<p>下載 <a href="https://drive.google.com/file/d/1FtyX29EcFwqlZ0xgzTCJVVol3Y_A9XBk/view?usp=sharing">Webots_R2020brev1_portable.7z</a></p>
<h4>參考資料:</h4>
<p><a href="https://github.com/mdecourse/RL_Webots">https://github.com/mdecourse/RL_Webots</a> </p>
<p><a href="https://drive.google.com/file/d/1fW0hZ24vqpDzuseVbZR60n9Z9-8MsP8c/view?usp=sharing">Deep Reinforcement Learning.pdf</a> (2019)</p>
<p><a href="https://drive.google.com/file/d/1If9EQqkmaIR8nZwHmyYHyx15OKvES4pw/view?usp=sharing">2020_Book_DeepReinforcementLearning.pdf</a></p>
<p><a href="https://drive.google.com/file/d/19irJA4Qchyew6XpucZPLYy5Nkyd7qQcF/view?usp=sharing">2019_Learning to Walk via Deep Reinforcement Learning</a></p>
<p><a href="https://drive.google.com/file/d/1a6o4GEwX7YJAuqf4PisMJzUn0g_l21O4/view?usp=sharing">2016_3d_simulated_robot_manipulation_using_deep_reinforcement_learning.pdf</a></p>
<p><a href="https://drive.google.com/file/d/11NfePzREpTGWD9aBGtjsrVWmRNma85hC/view?usp=sharing">2002_Book_HandbookOfMarkovDecisionProces.pdf</a></p>
<p><a href="https://link.springer.com/chapter/10.1007/978-3-030-49186-4_6">Deepbots: A Webots-Based Deep Reinforcement Learning Framework for Robotics</a></p>
<h2>LaTeX</h2>
<p><a href="https://github.com/sppmg/TW_Thesis_Template/wiki/%E7%84%A1%E8%85%A6%E6%89%8B%E5%86%8A">https://github.com/sppmg/TW_Thesis_Template/wiki/無腦手冊</a></p>
<p><a href="https://github.com/wengan-li/ncku-thesis-template-latex">https://github.com/wengan-li/ncku-thesis-template-latex</a></p>
<p><a href="https://github.com/HW-Lee/nthu-thesis-template">https://github.com/HW-Lee/nthu-thesis-template</a></p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">    Features &amp; Benefits
    Templates
    Plans &amp; Pricing
    Help
    Register
    Log In

NTUST Thesis template 1.7.1 (Chinese Version)
Author
Ding-Jie Huang, Chien-Chun Ni
License
Creative Commons CC BY 4.0
Abstract

This is the Chinese Version of NTUST thesis template v1.7.1, please check "NTUST Thesis template Overleaf English Version" if you need the English one.

本範本是為台灣科技大學同學們所編寫的碩博士論文Latex模板， 主要由元智大學碩博士論文latex範本改編而來， 期望加快各位同學撰寫論文的速度。

P.S 原始陳念波老師的元智大學論文範本為 http://exciton.eo.yzu.edu.tw/~lab/latex/latex_note.html

Support 14pt font for this version
Tags
Find More Templates
NTUST Thesis template 1.7.1 (Chinese Version)

    © 2020 OverleafPrivacy and TermsSecurityContact UsAboutBlog

    Overleaf on TwitterOverleaf on FacebookOverleaf on LinkedIn

Source

% this file is encoded in utf-8
% v1.7

\documentclass[12pt, a4paper]{ntust_report} 

\usepackage{fontspec}   %加這個就可以設定字體 
\usepackage{xeCJK}       %讓中英文字體分開設置 

%設定主要字型，也就是英文字型
\setmainfont[Mapping=tex-text]{Times New Roman}            

%設定中文字型
%參考 https://www.overleaf.com/learn/latex/Questions/What_OTF/TTF_fonts_are_supported_via_fontspec%3F#Chinese
\setCJKmainfont{cwTeXKai}      

\XeTeXlinebreaklocale "zh"                %這兩行一定要加，中文才能自動換行 
\XeTeXlinebreakskip = 0pt plus 1pt       %這兩行一定要加，中文才能自動換行

\input{common_env}  %基本的環境設定  無需改變  

\begin{document}


	\input{chinese_trans} %在此檔案處定義文章中的中文名詞

	%----------------------------------------------------------------------------------------------------------------------------------------------------------
	%%% 以下是載入前頁、本文、後頁
	% 此行請勿更動

	%----------------------------------------------------------------------------------------------------------------------------------------------------------
	% front matter 前頁
	% 包括封面、書名頁、中文摘要、英文摘要、誌謝、目錄、表目錄、圖目錄、符號說明
	% 在撰寫各章草稿時，可以把此部份「關掉」，以節省無謂的編譯時間。
	% 實際內容由
	%    my_names.tex, my_cabstract.tex, my_eabstract.tex, my_ackn.tex, my_symbols.tex
	% 決定
	% ntust_frontpages.tex 此檔只提供整體架構的定義，不需更動
	% 在撰寫各章草稿時，可以把此部份「關掉」，以節省無謂的編譯時間。
	
	\input{frontpages/ntust_frontpages.tex} 




	%----------------------------------------------------------------------------------------------------------------------------------------------------------
	% main body 論文主體。建議以「章」為檔案分割的依據。
	% 以下為建議的命名分類
	%   introduction.tex   related_work.tex  protocol.tex  evaluation.tex  conclusion.tex
	% 做為這幾個「章」的檔案名稱，並將檔案存放於資料夾 sections/ 下
	% 實際命名方式可以隨你意
	% 在撰寫各章草稿時，可以把其他章節關掉 (行首加百分號)
	%\input{example/example_body.tex}  % 所附的範例

	\input{sections/introduction.tex}
	\input{sections/relative-work.tex}
	\input{sections/method.tex}
	\input{sections/Design.tex}
	\input{sections/evaluation.tex}
	\input{sections/Conclusion.tex}

	%----------------------------------------------------------------------------------------------------------------------------------------------------------
	% back pages 後頁
	% 包括參考文獻、附錄、自傳
	% 實際內容由
	%    my_bib.bib, my_appendix.tex, my_vita.tex
	% 決定
	% ntust_backpages.tex 此檔只提供整體架構的定義，不需更動
	% 在撰寫各章草稿時，可以把此部份「關掉」，以節省無謂的編譯時間。
	%\bibliographystyle{unsrt} 
	\input{backpages/ntust_backpages.tex}
	%\bibliographystyle{unsrt} 



\end{document} 
 

</pre>
<p></p>
<h2>參考資料</h2>
<ol>
<li><a href="https://easyai.tech/en/blog/reinforcement-learning-with-python/">https://easyai.tech/en/blog/reinforcement-learning-with-python/</a></li>
<li><a href="https://github.com/openai/gym">https://github.com/openai/gym</a></li>
<li><a href="https://github.com/bhyang/gym-vrep">https://github.com/bhyang/gym-vrep</a></li>
<li><a href="https://arxiv.org/pdf/1608.05742.pdf">https://arxiv.org/pdf/1608.05742.pdf</a></li>
<li><a href="https://github.com/stepjam/PyRep">https://github.com/stepjam/PyRep</a></li>
<li><a href="https://arxiv.org/abs/1906.11176">https://arxiv.org/abs/1906.11176</a></li>
<li><a href="https://github.com/ycps/vrep-env">https://github.com/ycps/vrep-env</a></li>
<li><a href="https://towardsdatascience.com/learning-to-drive-smoothly-in-minutes-450a7cdb35f4">https://towardsdatascience.com/learning-to-drive-smoothly-in-minutes-450a7cdb35f4</a></li>
<li><a href="https://github.com/araffin/learning-to-drive-in-5-minutes">https://github.com/araffin/learning-to-drive-in-5-minutes</a></li>
<li><a href="https://www.learndatasci.com/tutorials/reinforcement-q-learning-scratch-python-openai-gym/">https://www.learndatasci.com/tutorials/reinforcement-q-learning-scratch-python-openai-gym/</a></li>
<li><a href="https://upcommons.upc.edu/bitstream/handle/2117/133279/tfm-alex-cabaneros.pdf">https://upcommons.upc.edu/bitstream/handle/2117/133279/tfm-alex-cabaneros.pdf</a></li>
</ol>
<h2>研究生考試</h2>
<p>csme 研究生考試科目與題型: <a href="http://csme.org.tw/Certification/College.aspx?AwardID=62">考試內容</a>及<a href="http://csme.org.tw/Certification/Prepare.aspx?NewsType=2">考古題</a></p>
<h1>動態網站</h1>
<p>設定步驟請參考:</p>
<p><a href="https://github.com/mdecourse/project2020-1/issues/4">https://github.com/mdecourse/project2020-1/issues/4</a></p>
<h4>CMSiMDE 執行所需模組</h4>
<p style="padding-left: 30px;"><span>sudo pip3 install flask flask_cors bs4 lxml</span></p>
<h4>uwsgi 所需模組</h4>
<pre style="padding-left: 30px;"><code>sudo apt install uwsgi uwsgi-plugin-python3<br/><br/></code></pre>
<pre style="padding-left: 30px;"><code>sudo pip3 install uwsgi</code></pre>
<pre><code><br/></code>/etc/nginx/sites-available/default 附加 server 設定 <br/><br/></pre>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">server {
 
    listen 9443 ssl;
    listen [::]:9443 ssl;
 
    # 指定 static 所在位置
    location /static {
	alias /home/yen/cad1_site/cmsimde/static/;
    }
 
    location / {
	# 導入 uwsgi_params 設定參數
	include uwsgi_params;
	# 根目錄設為近端的 8080 port 
	uwsgi_pass  127.0.0.1:8080;
    }
 
    ssl_certificate /home/yen/localhost.crt;
    ssl_certificate_key /home/yen/localhost.key;
    #ssl_certificate /etc/letsencrypt/live/cad1.kmol.info/fullchain.pem;
    #ssl_certificate_key /etc/letsencrypt/live/cad1.kmol.info/privkey.pem;
    ssl_session_timeout 5m;
    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES";
    ssl_prefer_server_ciphers on;
    try_files $uri $uri/ =404;
}</pre>
<h4><br/>建立 self-signed key<br/><br/><span>sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout localhost.key -out localhost.crt</span><br/><br/>/home/yen/uwsgi_ini/uwsgi.ini<br/><br/></h4>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">[uwsgi]
socket = :8080
uid = yen
gid = yen
plugins-dir = /usr/lib/uwsgi/plugins/
plugin = python3
master = true
process = 4
threads = 2
chdir = /home/yen/cad1_site/cmsimde
wsgi-file = /home/yen/cad1_site/cmsimde/wsgi.py</pre>
<h4><br/>uwsgi emperor 手動測試</h4>
<h4><code>/usr/bin/uwsgi --emperor /home/yen/uwsgi_ini<br/><br/>防火牆設定<br/></code></h4>
<p>先暫時關閉 ufw</p>
<p>ufw disable</p>
<p>允許設計系 IP v6 網段連線 9443 port</p>
<p>ufw allow from 2001:288:6004:17::/32 to any port 9443</p>
<p>其他網段主機一律]不准連線</p>
<p>ufw deny 9443</p>
<p>重新開啟 ufw 防火牆</p>
<p>ufw enable</p>
<pre><code><span>/etc/systemd/system 目錄中建立 cmsimde.service 檔案</span></code></pre>
<pre></pre>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">[Unit]
Description=uWSGI to serve CMSiMDE 
After=network.target
 
[Service]
User=yen
Group=yen
WorkingDirectory=/home/yen/uwsgi_ini
ExecStart=/usr/bin/uwsgi --emperor /home/yen/uwsgi_ini
 
[Install]
WantedBy=multi-user.target</pre>
<pre></pre>
<p>接著將 cmsimde 服務設為隨系統開機啟動:</p>
<pre><code>sudo systemctl enable cmsimde
</code></pre>
<p>若要取消 cmsimde 服務隨系統開機啟動:</p>
<pre><code>sudo systemctl disable cmsimde
</code></pre>
<p>手動啟動 cmsimde.service 服務</p>
<pre><code>sudo systemctl start cmsimde
</code></pre>
<p>手動停止 cmsimde.service 服務</p>
<pre><code>sudo systemctl stop cmsimde</code></pre>
<pre><br/><br/></pre>
<h2>數位簽章</h2>
<p><a href="https://letsencrypt.org/">https://letsencrypt.org/</a></p>
<p><a href="https://certbot.eff.org/lets-encrypt/ubuntufocal-nginx">https://certbot.eff.org/lets-encrypt/ubuntufocal-nginx</a> </p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">sudo apt-get update
sudo apt-get install software-properties-common
sudo add-apt-repository universe
sudo apt-get update

sudo apt-get install certbot python3-certbot-nginx

sudo certbot certonly --nginx

sudo certbot renew --dry-run</pre>
<p></p>
<h2>機電控制</h2>
<p>Mechatronic system control</p>
<h4>控制卡:</h4>
<p style="padding-left: 30px;">Arduino</p>
<p style="padding-left: 30px;">Raspberry Pi</p>
<h4>機電系統:</h4>
<p style="padding-left: 30px;">iRobot Create</p>
<h2>iRobot Create</h2>
<p><a href="https://www.cyberbotics.com/doc/guide/create">https://www.cyberbotics.com/doc/guide/create</a></p>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/dEgLYioQycA" width="560"></iframe></p>
<p><a href="https://github.com/mgobryan/pycreate">https://github.com/mgobryan/pycreate</a> </p>
<p><a href="https://github.com/mdecourse/create_autonomy">https://github.com/mdecourse/create_autonomy</a> </p>
<p><a href="/downloads/CreateManual_Final.pdf">iRobot Create Manual.pdf</a></p>
<p><a href="/downloads/iRobot Create Robot - Cookbook _ Mbed.pdf">iRobot Create cookbook.pdf</a></p>
<p><a href="/downloads/CommandModuleManual_v2.pdf">iRobot Create Command Module manual v2.pdf</a></p>
<p><a href="/downloads/CreateOpenInterface_v2.pdf">iRobot Create Open Interface v2.pdf</a></p>
<p><a href="/downloads/AD41700_Arduino_iRobot_workshop.pdf">Use Arduino to control iRobot Create.pdf</a></p>
<p><a href="/downloads/AD61600_Arduino_iRobot.pdf">Use Arduino to control iRobot Create_2.pdf</a></p>
<h1>深度學習</h1>
<p><a href="/downloads/Solving Nonlinear andHigh-Dimensional PartialDifferential Equations viaDeep Learning.pdf">Solving Nonlinear andHigh-Dimensional PartialDifferential Equations viaDeep Learning.pdf</a></p>
<p style="padding-left: 30px;"><a href="https://github.com/alialaradi/DeepGalerkinMethod">https://github.com/alialaradi/DeepGalerkinMethod</a></p>
<p><a href="/downloads/DGM A deep learning algorithm for solving partial differentialequations.pdf">DGM A deep learning algorithm for solving partial differentialequations.pdf</a></p>
<p></p>
<p><a href="https://cloud4scieng.org/">https://cloud4scieng.org/</a> 雲端運算</p>
<p><a href="https://www.uio.no/studier/emner/matnat/ifi/IN5400/v20/material/week1/">https://www.uio.no/studier/emner/matnat/ifi/IN5400/v20/material/week1/</a></p>
<p><a href="https://wcm.kmol.info:8443">https://wcm.kmol.info:8443</a> (KMOLer only)</p>
<p><a href="https://github.com/mdecourse/cd2020pj1">https://github.com/mdecourse/cd2020pj1</a></p>
<p><a href="https://cs.stanford.edu/people/karpathy/convnetjs/">https://cs.stanford.edu/people/karpathy/convnetjs/ </a></p>
<p><a href="http://neuralnetworksanddeeplearning.com/chap1.html">http://neuralnetworksanddeeplearning.com/chap1.html</a> </p>
<p><a href="https://cs.stanford.edu/people/karpathy/convnetjs/demo/rldemo.html">https://cs.stanford.edu/people/karpathy/convnetjs/demo/rldemo.html</a></p>
<p><a href="http://deeplearning.net/">http://deeplearning.net/</a></p>
<p><a href="/downloads/Playing Atari with Deep Reinforcement Learning.pdf">Playing Atari with Deep Reinforcement Learning.pdf</a></p>
<p><a href="/downloads/robust_auto_parking_reinforcement_learning_based_real_time_planning_approach_with_domain_template.pdf">Robust Auto-parking: Reinforcement Learning based Real-time Planning Approach with Domain Template.pdf</a></p>
<p><a href="/downloads/AutomaticCarParkingAReinforcem.pdf">Automatic Car Parking: A Reinforcement Learning Approach.pdf</a></p>
<p><a href="/downloads/Real-time image-based parking occupancy detection.pdf">Real-time image-based parking occupancy detection using deep learning.pdf</a></p>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/VMp6pq6_QjI" width="560"></iframe></p>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/MlFZjLkEIEw" width="560"></iframe></p>
<p>以下為 convnet javascript 應用</p>
<!-- import convnetjs library -->
<script src="/downloads/convnet-min.js"></script>
<!-- javascript goes here -->
<script type="text/javascript">
function periodic() {
  var d = document.getElementById('egdiv');
  d.innerHTML = 'Random number: ' + Math.random()
}
 
var net; // declared outside -> global variable in window scope
function start() {
  // this gets executed on startup
  //... 
  net = new convnetjs.Net();
  // ...
 
  // example of running something every 1 second
  setInterval(periodic, 1000);
}
</script>
<script>
window.onload=start();
</script>
<h2>電腦</h2>
<p><a href="https://drive.google.com/file/d/1AaOdJdZPNiD3YE5kgNcIrLK7ic0qsme1/view?usp=sharing">專題可攜 22GB.7z</a></p>
<p>電腦輔助設計室 2016 更換的<a href="http://project.mde.tw/blog/yen-dian-nao-fu-zhu-she-ji-shi-dian-nao-pei-zhi.html">電腦硬體</a>:</p>
<p>2016-2 協同設計室 6 台電腦</p>
<p>Intel Core i7-6700 3.4 GHz Ram 16GB</p>
<p>顯示卡 NVIDIA GeForce GTX 950 2GB 768 CUDA cores version 10.1</p>
<p><a href="https://pytorch.org/get-started/locally/">安裝 Pytorch 指令</a>:</p>
<pre>pip install torch==1.5.1+cu101 torchvision==0.6.1+cu101 -f <a href="https://download.pytorch.org/whl/torch_stable.html">https://download.pytorch.org/whl/torch_stable.html</a><br/><br/><a href="https://github.com/pytorch/examples">https://github.com/pytorch/examples</a><br/><a href="https://drive.google.com/file/d/1ke4bwuKZYeGArfQHwPfwTQSLTL3c-g-i/view?usp=sharing"><br/>Deep learning with python.pdf<br/><br/></a><a href="https://drive.google.com/file/d/1tofwQZBpb-cApownNTREDLgF-nd7WgoU/view?usp=sharing">Deep Learning with Pytorch.pdf</a> (<a href="https://pytorch.org/assets/deep-learning/Deep-Learning-with-PyTorch.pdf">來源</a>)</pre>
<h2>Flask</h2>
<p>Flutter 前端與後端 Flask + Keras 結合應用</p>
<div style="padding-left: 30px;"><a href="https://medium.com/analytics-vidhya/deploy-deep-learning-models-as-rest-apis-using-keras-and-access-from-a-flutter-app-9a6752f0d907">https://medium.com/analytics-vidhya/deploy-deep-learning-models-as-rest-apis-using-keras-and-access-from-a-flutter-app-9a6752f0d907</a></div>
<div></div>
<div>Flutter send image file to backend:</div>
<div>
<pre class="brush:dart;auto-links:false;toolbar:false" contenteditable="false">import 'package:flutter/material.dart';
import 'dart:io';
import 'package:http/http.dart' as http;
import 'package:image_picker/image_picker.dart';
import 'package:mime/mime.dart';
import 'dart:convert';
import 'package:http_parser/http_parser.dart';
import 'package:toast/toast.dart';

void main() =&gt; runApp(MyApp());

class MyApp extends StatelessWidget {
  // This widget is the root of your application.
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
        title: 'Image Upload Demo',
        theme: ThemeData(primarySwatch: Colors.pink),
        home: ImageInput());
  }
}

class ImageInput extends StatefulWidget {
  @override
  State&lt;StatefulWidget&gt; createState() {
    return _ImageInput();
  }
}

class _ImageInput extends State&lt;ImageInput&gt; {
  // To store the file provided by the image_picker
  File _imageFile;

  // To track the file uploading state
  bool _isUploading = false;

  String baseUrl = 'http://YOUR_IPV4_ADDRESS/flutterdemoapi/api.php';

  void _getImage(BuildContext context, ImageSource source) async {
    File image = await ImagePicker.pickImage(source: source);

    setState(() {
      _imageFile = image;
    });

    // Closes the bottom sheet
    Navigator.pop(context);
  }

  Future&lt;Map&lt;String, dynamic&gt;&gt; _uploadImage(File image) async {
    setState(() {
      _isUploading = true;
    });

    // Find the mime type of the selected file by looking at the header bytes of the file
    final mimeTypeData =
        lookupMimeType(image.path, headerBytes: [0xFF, 0xD8]).split('/');

    // Intilize the multipart request
    final imageUploadRequest =
        http.MultipartRequest('POST', Uri.parse(baseUrl));

    // Attach the file in the request
    final file = await http.MultipartFile.fromPath('image', image.path,
        contentType: MediaType(mimeTypeData[0], mimeTypeData[1]));

    // Explicitly pass the extension of the image with request body
    // Since image_picker has some bugs due which it mixes up
    // image extension with file name like this filenamejpge
    // Which creates some problem at the server side to manage
    // or verify the file extension
    imageUploadRequest.fields['ext'] = mimeTypeData[1];

    imageUploadRequest.files.add(file);

    try {
      final streamedResponse = await imageUploadRequest.send();

      final response = await http.Response.fromStream(streamedResponse);

      if (response.statusCode != 200) {
        return null;
      }

      final Map&lt;String, dynamic&gt; responseData = json.decode(response.body);

      _resetState();

      return responseData;
    } catch (e) {
      print(e);
      return null;
    }
  }

  void _startUploading() async {
    final Map&lt;String, dynamic&gt; response = await _uploadImage(_imageFile);
    print(response);
    // Check if any error occured
    if (response == null || response.containsKey("error")) {
      Toast.show("Image Upload Failed!!!", context,
          duration: Toast.LENGTH_LONG, gravity: Toast.BOTTOM);
    } else {
      Toast.show("Image Uploaded Successfully!!!", context,
          duration: Toast.LENGTH_LONG, gravity: Toast.BOTTOM);
    }
  }

  void _resetState() {
    setState(() {
      _isUploading = false;
      _imageFile = null;
    });
  }

  void _openImagePickerModal(BuildContext context) {
    final flatButtonColor = Theme.of(context).primaryColor;
    print('Image Picker Modal Called');
    showModalBottomSheet(
        context: context,
        builder: (BuildContext context) {
          return Container(
            height: 150.0,
            padding: EdgeInsets.all(10.0),
            child: Column(
              children: &lt;Widget&gt;[
                Text(
                  'Pick an image',
                  style: TextStyle(fontWeight: FontWeight.bold),
                ),
                SizedBox(
                  height: 10.0,
                ),
                FlatButton(
                  textColor: flatButtonColor,
                  child: Text('Use Camera'),
                  onPressed: () {
                    _getImage(context, ImageSource.camera);
                  },
                ),
                FlatButton(
                  textColor: flatButtonColor,
                  child: Text('Use Gallery'),
                  onPressed: () {
                    _getImage(context, ImageSource.gallery);
                  },
                ),
              ],
            ),
          );
        });
  }

  Widget _buildUploadBtn() {
    Widget btnWidget = Container();

    if (_isUploading) {
      // File is being uploaded then show a progress indicator
      btnWidget = Container(
          margin: EdgeInsets.only(top: 10.0),
          child: CircularProgressIndicator());
    } else if (!_isUploading &amp;&amp; _imageFile != null) {
      // If image is picked by the user then show a upload btn

      btnWidget = Container(
        margin: EdgeInsets.only(top: 10.0),
        child: RaisedButton(
          child: Text('Upload'),
          onPressed: () {
            _startUploading();
          },
          color: Colors.pinkAccent,
          textColor: Colors.white,
        ),
      );
    }

    return btnWidget;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('Image Upload Demo'),
      ),
      body: Column(
        children: &lt;Widget&gt;[
          Padding(
            padding: const EdgeInsets.only(top: 40.0, left: 10.0, right: 10.0),
            child: OutlineButton(
              onPressed: () =&gt; _openImagePickerModal(context),
              borderSide:
                  BorderSide(color: Theme.of(context).accentColor, width: 1.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: &lt;Widget&gt;[
                  Icon(Icons.camera_alt),
                  SizedBox(
                    width: 5.0,
                  ),
                  Text('Add Image'),
                ],
              ),
            ),
          ),
          _imageFile == null
              ? Text('Please pick an image')
              : Image.file(
                  _imageFile,
                  fit: BoxFit.cover,
                  height: 300.0,
                  alignment: Alignment.topCenter,
                  width: MediaQuery.of(context).size.width,
                ),
          _buildUploadBtn(),
        ],
      ),
    );
  }
}</pre>
<p>Server 端, 必須將 php 改為 Flask:</p>
<pre class="brush:php;auto-links:false;toolbar:false" contenteditable="false">    &lt;?php
    if(isset($_FILES["image"]["name"])) {
      
        // Make sure you have created this directory already
        $target_dir = "uploads/";
      
        // Generate a random name 
        $target_file = $target_dir . md5(time()) . '.' . $_POST['ext'];
        $check = getimagesize($_FILES["image"]["tmp_name"]);
        if($check !== false) {
            if (move_uploaded_file($_FILES["image"]["tmp_name"], $target_file)) {
          echo json_encode(['response' =&gt; "The image has been uploaded."]);
           }else {
          echo json_encode(["error" =&gt; "Sorry, there was an error uploading your file."]); 
        }
        } else {
            echo json_encode(["error" =&gt; "File is not an image."]);
           
        }
    }
     else {
         echo json_encode(["error" =&gt; "Please provide a image to upload"]);
    }
    ?&gt;</pre>
<p></p>
</div>
<h1>強化學習</h1>
<p><a href="https://github.com/dennybritz/reinforcement-learning">https://github.com/dennybritz/reinforcement-learning</a></p>
<p><a href="http://incompleteideas.net/book/RLbook2018.pdf">http://incompleteideas.net/book/RLbook2018.pdf</a></p>
<h4>Artificial Intelligence ( <a href="https://www.youtube.com/watch?v=J8Eh7RqggsU&amp;list=PLoROMvodv4rO1NB9TD4iUZ3qghGEGtqNX">人工智慧系列課程</a>)</h4>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/J8Eh7RqggsU" width="560"></iframe></p>
<h4>Machine Learning (<a href="https://www.youtube.com/watch?v=jGwO_UgTS7I&amp;list=PLoROMvodv4rMiGQp3WXShtMGgzqpfVfbU">機器學習系列課程</a>)</h4>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/jGwO_UgTS7I" width="560"></iframe></p>
<h4>Reinforcement Learning (<a href="https://www.youtube.com/watch?v=FgzM3zpZ55o&amp;list=PLoROMvodv4rOSOPzutgyCTapiGlY2Nd8u">強化學習系列課程</a>)</h4>
<p style="padding-left: 30px;">Learn to make good sequences of decision.</p>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/FgzM3zpZ55o" width="560"></iframe></p>
<p><a href="https://github.com/keras-rl/keras-rl">https://github.com/keras-rl/keras-rl</a></p>
<p><a href="https://towardsdatascience.com/learning-reinforcement-learning-reinforce-with-pytorch-5e8ad7fc7da0">https://towardsdatascience.com/learning-reinforcement-learning-reinforce-with-pytorch-5e8ad7fc7da0</a></p>
<p><a href="https://github.com/astooke/rlpyt">https://github.com/astooke/rlpyt</a> (<a href="https://rlpyt.readthedocs.io/en/latest/">Document</a>) (<a href="https://bair.berkeley.edu/blog/2019/09/24/rlpyt/">Blog</a>)</p>
<p><a href="https://github.com/p-christ/Deep-Reinforcement-Learning-Algorithms-with-PyTorch">https://github.com/p-christ/Deep-Reinforcement-Learning-Algorithms-with-PyTorch</a></p>
<p><a href="https://openai.com/blog/openai-baselines-ppo/">https://openai.com/blog/openai-baselines-ppo/</a> </p>
<p>Deep Q Learning</p>
<p><iframe allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen="allowfullscreen" frameborder="0" height="315" src="https://www.youtube.com/embed/UlJzzLYgYoE" width="560"></iframe></p>
<p>Vanilla Policy Gradient Method</p>
<p>Trust Region / Natural Policy Gradient Methods</p>
<p><a href="/downloads/Proximal Policy Optimization Algorithms.pdf">Proximal Policy Optimization Algorithms.pdf</a> ( 近端策略優化原理)</p>
<p><a href="https://pytorch.org/tutorials/intermediate/reinforcement_q_learning.html">https://pytorch.org/tutorials/intermediate/reinforcement_q_learning.html</a></p>
<p><a href="https://www.mlq.ai/deep-reinforcement-learning-pytorch-implementation/">https://www.mlq.ai/deep-reinforcement-learning-pytorch-implementation/</a></p>
<h2>2021</h2>
<p>need Python and Node.js and Typescript</p>
<p><a href="https://github.com/Positronic-IO/air-hockey-training-environment">https://github.com/Positronic-IO/air-hockey-training-environment</a> </p>
<p><a href="https://github.com/Positronic-IO/air-hockey-web-ui">https://github.com/Positronic-IO/air-hockey-web-ui</a> </p>
<p><a href="https://jonathan-hui.medium.com/rl-dqn-deep-q-network-e207751f7ae4">https://jonathan-hui.medium.com/rl-dqn-deep-q-network-e207751f7ae4</a> </p>
<p><a href="https://keon.github.io/">https://keon.github.io/</a> </p>
<h2>Reference</h2>
<p><a href="/downloads/2018_Robotic Harvesting of Fruiting Vegetables-A Simulation Approach in V-REP, ROS and MATLAB.pdf">2018_Robotic Harvesting of Fruiting Vegetables-A Simulation Approach in V-REP, ROS and MATLAB.pdf</a></p>
<p><a href="/downloads/2019_Hovering Control of a Quadrotor.pdf">2019_Hovering Control of a Quadrotor.pdf</a></p>
<p><a href="/downloads/2019_Accelerating Training of Deep Reinforcement Learning-based Autonomous Driving Agents Through Comparative Study of Agent and Environment Designs.pdf">2019_Accelerating Training of Deep Reinforcement Learning-based Autonomous Driving Agents Through Comparative Study of Agent and Environment Designs.pdf</a></p>
<p><a href="/downloads/2018_Curved Path Following with Deep Reinforcement Learning-Results from Three Vessel Models.pdf">2018_Curved Path Following with Deep Reinforcement Learning-Results from Three Vessel Models.pdf</a></p>
<p><a href="/downloads/2019_Application of deep reinforcement learning for control problems.pdf">2019_Application of deep reinforcement learning for control problems.pdf</a></p>
<p><a href="/downloads/2018_Path Following in Simulated Environments using the A3C Reinforcement Learning Method.pdf">2018_Path Following in Simulated Environments using the A3C Reinforcement Learning Method.pdf</a></p>
<p><a href="/downloads/FlashRL_A Reinforcement Learning Platform.pdf">FlashRL_A Reinforcement Learning Platform.pdf</a></p>
<h2>類神經網路學習</h2>
<p><a href="https://drive.google.com/file/d/1yc0WjEN33IKjgmZZlxO5LcT--qkDRZXu/view">nn_and_air_hockey.7z</a></p>
<p>將 <a href="https://github.com/Purusharth07/Ping-Pong-Neural-Game-">https://github.com/Purusharth07/Ping-Pong-Neural-Game-</a>  改為 <a href="https://drive.google.com/file/d/1ZfkzhZBLRQSuKYsaKO2UPOC3ZvV9KaiC/view">tensorflow 2.0</a> 版本, 使用 Pygame 模擬.</p>
<h3>neural_network_in_python.pdf</h3>
<p>說明前三章的程式碼</p>
<h4>2LayerNeuralNetwork.py</h4>
<p><strong>origin codes:</strong></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"># 2 Layer Neural Network in NumPy
import numpy as np
# X = input of our 3 input XOR gate
# set up the inputs of the neural network (right from the table)
X = np.array(([0,0,0],[0,0,1],[0,1,0], [0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]), dtype=float)
# y = our output of our neural network
y = np.array(([1], [0], [0], [0], [0], [0], [0], [1]), dtype=float)
# what value we want to predict
xPredicted = np.array(([0,0,1]), dtype=float)
X = X/np.amax(X, axis=0) # maximum of X input array
# maximum of xPredicted (our input data for the prediction)
xPredicted = xPredicted/np.amax(xPredicted, axis=0)
# set up our Loss file for graphing
lossFile = open("SumSquaredLossList.csv", "w")
class Neural_Network (object):
    def __init__(self):
        #parameters
        self.inputLayerSize = 3 # X1,X2,X3
        self.outputLayerSize = 1 # Y1
        self.hiddenLayerSize = 4 # Size of the hidden layer
        # build weights of each layer
        # set to random values
        # look at the interconnection diagram to make sense of this
        # 3x4 matrix for input to hidden
        self.W1 = np.random.randn(self.inputLayerSize, self.hiddenLayerSize)
        # 4x1 matrix for hidden layer to output
        self.W2 = np.random.randn(self.hiddenLayerSize, self.outputLayerSize)
    def feedForward(self, X):
        # feedForward propagation through our network
        # dot product of X (input) and first set of 3x4 weights
        self.z = np.dot(X, self.W1)
        # the activationSigmoid activation function - neural magic
        self.z2 = self.activationSigmoid(self.z)
        # dot product of hidden layer (z2) and second set of 4x1 weights
        self.z3 = np.dot(self.z2, self.W2)
        # final activation function - more neural magic
        o = self.activationSigmoid(self.z3)
        return o
     def backwardPropagate(self, X, y, o):
        # backward propagate through the network
        # calculate the error in output
        self.o_error = y - o
        # apply derivative of activationSigmoid to error
        self.o_delta = self.o_error*self.activationSigmoidPrime(o)
        # z2 error: how much our hidden layer weights contributed to output
        # error
        self.z2_error = self.o_delta.dot(self.W2.T)
        # applying derivative of activationSigmoid to z2 error
        self.z2_delta = self.z2_error*self.activationSigmoidPrime(self.z2)
        # adjusting first set (inputLayer --&gt; hiddenLayer) weights
        self.W1 += X.T.dot(self.z2_delta)
        # adjusting second set (hiddenLayer --&gt; outputLayer) weights
        self.W2 += self.z2.T.dot(self.o_delta)
    def trainNetwork(self, X, y):
        # feed forward the loop
        o = self.feedForward(X)
        # and then back propagate the values (feedback)
        self.backwardPropagate(X, y, o)
    def activationSigmoid(self, s):
        # activation function
        # simple activationSigmoid curve as in the book
        return 1/(1+np.exp(-s))
    def activationSigmoidPrime(self, s):
        # First derivative of activationSigmoid
        # calculus time!
        return s * (1 - s)
    def saveSumSquaredLossList(self,i,error):
        lossFile.write(str(i)+","+str(error.tolist())+'\n')
    def saveWeights(self):
        # save this in order to reproduce our cool network
        np.savetxt("weightsLayer1.txt", self.W1, fmt="%s")
        np.savetxt("weightsLayer2.txt", self.W2, fmt="%s")
    def predictOutput(self):
        print ("Predicted XOR output data based on trained weights: ")
        print ("Expected (X1-X3): \n" + str(xPredicted))
        print ("Output (Y1): \n" + str(self.feedForward(xPredicted)))

myNeuralNetwork = Neural_Network()
trainingEpochs = 1000
#trainingEpochs = 100000

for i in range(trainingEpochs): # train myNeuralNetwork 1,000 times
    print ("Epoch # " + str(i) + "\n")
    print ("Network Input : \n" + str(X))
    print ("Expected Output of XOR Gate Neural Network: \n" + str(y))
    print ("Actual Output from XOR Gate Neural Network: \n" + \
    str(myNeuralNetwork.feedForward(X)))
    # mean sum squared loss
    Loss = np.mean(np.square(y - myNeuralNetwork.feedForward(X)))
    myNeuralNetwork.saveSumSquaredLossList(i,Loss)
    print ("Sum Squared Loss: \n" + str(Loss))
    print ("\n")
    myNeuralNetwork.trainNetwork(X, y)

myNeuralNetwork.saveWeights()
myNeuralNetwork.predictOutput()p</pre>
<p><strong>定義input(X)和output(Y)</strong></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">X = np.array(([0,0,0],[0,0,1],[0,1,0], [0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]), dtype=float)
y = np.array(([1], [0], [0], [0], [0], [0], [0], [1]), dtype=float)</pre>
<p><strong>設定神經元及權重</strong></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">python
 def __init__(self):
        # X1,X2,X3(自訂義input的神經元數量)
        self.inputLayerSize = 3
        # Y1(自訂義output的神經元數量)   
        self.outputLayerSize = 1
        # Size of the hidden layer(自訂義hiddenLayer的神經元數量)          
        self.hiddenLayerSize = 4 
        
        # 設定第一層權重為隨機數值，input---&gt;hidden
        self.W1 = np.random.randn(self.inputLayerSize, self.hiddenLayerSize)
        
        # 設定第二層權重為隨機數值，hidden---&gt;output
        self.W2 = np.random.randn(self.hiddenLayerSize, self.outputLayerSize)
</pre>
<p><strong>feedForward(前饋)</strong></p>
<p><img alt="" height="361" src="/images/NN_layers.png" width="500"/></p>
<p><a href="https://medium.com/ai-academy-taiwan/back-propagation-3946e8ed8c55">(圖片來源)</a></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"> def feedForward(self, X):
        # 第一層的動態方程式(activation function)輸入(z)
        # z(activation function) = 第一層所有神經元的 input * weights 總和輸入到第二層的其中一個神經元
        self.z = np.dot(X, self.W1)

        # 第一層的動態方程式(activation function)輸出(a)
        # z2(a) = 動態方程式(activation function)用Sigmoid function算法
        self.z2 = self.activationSigmoid(self.z)

        # 第二層的動態方程式(activation function)輸入(z)
        # z3(activation function) = 第二層所有神經元的 input * weights 總和輸入到輸出層的(其中一個)神經元
        self.z3 = np.dot(self.z2, self.W2)

        # 第二層的動態方程式(activation function)輸出(a)
        # o(a) = 動態方程式(activation function)用Sigmoid function算法
        o = self.activationSigmoid(self.z3)

        # 回傳出前饋結果
        return o</pre>
<p><strong>backwardPropagate(反向傳播)</strong></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def backwardPropagate(self, X, y, o):
        # 計算輸出誤差
        self.o_error = y - o

        # 將Sigmoid function算法用在輸出誤差(錯誤、error)
        self.o_delta = self.o_error*self.activationSigmoidPrime(o)

        # 隱藏層的輸出誤差*權重
        self.z2_error = self.o_delta.dot(self.W2.T)

        # 將Sigmoid function算法用在隱藏層輸出誤差(錯誤、error)
        self.z2_delta = self.z2_error*self.activationSigmoidPrime(self.z2)

        # 糾正第一層權重數值，input---&gt;hidden
        self.W1 += X.T.dot(self.z2_delta)
        # 糾正第二層權重數值，hidden---&gt;output
        self.W2 += self.z2.T.dot(self.o_delta)</pre>
<p><strong>trainNetwork(訓練流程)</strong></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def trainNetwork(self, X, y):
        # 前饋循環 
        o = self.feedForward(X)
        # 反向傳播值
        self.backwardPropagate(X, y, o)</pre>
<p><strong>activationSigmoid</strong></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def activationSigmoid(self, s):
        # activation function
        # 使用Sigmoid function算法(S-curve)
        return 1/(1+np.exp(-s))</pre>
<p><img caption="false" height="70" src="/images/Sigmoid_Function.png" width="166"/></p>
<p><strong>activationSigmoidPrime</strong></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def activationSigmoidPrime(self, s):
        # First derivative of activationSigmoid
        # calculus time!
        return s * (1 - s)</pre>
<p><strong><img caption="false" height="50" src="/images/Sigmoid_function_prime.jpg" width="257"/></strong></p>
<p><strong>saveSumSquaredLossList(儲存損失函數值)</strong></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"> def saveSumSquaredLossList(self,i,error):
        lossFile.write(str(i)+","+str(error.tolist())+'\n')</pre>
<p><strong>saveWeights(儲存權重值)</strong></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false"> def saveWeights(self):
        np.savetxt("weightsLayer1.txt", self.W1, fmt="%s")
        np.savetxt("weightsLayer2.txt", self.W2, fmt="%s")</pre>
<p><strong>predictOutput(結果輸出)</strong></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def predictOutput(self):
        print ("Predicted XOR output data based on trained weights: ")
        print ("Expected (X1-X3): \n" + str(xPredicted))
        print ("Output (Y1): \n" + str(self.feedForward(xPredicted)))</pre>
<p><strong>Epochs(疊代次數，feedForward+backprogation運算完算一次疊代)</strong></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false"># 訓練疊代次數
trainingEpochs = 1000</pre>
<h4>TensorFlowKeras.py</h4>
<p><strong>origin codes:</strong></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import tensorflow as tf
from tensorflow.keras import layers
from tensorflow.keras.layers import Activation, Dense
import numpy as np
# X = input of our 3 input XOR gate
# set up the inputs of the neural network (right from the table)
X = np.array(([0,0,0], [0,0,1], [0,1,0], [0,1,1], [1,0,0], [1,0,1], [1,1,0], [1,1,1]), dtype=float)
# y = our output of our neural network
y = np.array(([1], [0], [0], [0], [0], [0], [0], [1]), dtype=float)
model = tf.keras.Sequential()
model.add(Dense(4, input_dim=3, activation='relu', use_bias=True))
#model.add(Dense(4, activation='relu', use_bias=True))
model.add(Dense(1, activation='sigmoid', use_bias=True))
model.compile(loss='mean_squared_error', optimizer='adam', metrics=['binary_accuracy'])
print (model.get_weights())
history = model.fit(X, y, epochs=2000, validation_data = (X, y))
model.summary()
# printing out to file
loss_history = history.history["loss"]
numpy_loss_history = np.array(loss_history)
np.savetxt("loss_history.txt", numpy_loss_history, delimiter="\n")
binary_accuracy_history = history.history["binary_accuracy"]
numpy_binary_accuracy = np.array(binary_accuracy_history)
np.savetxt("binary_accuracy.txt", numpy_binary_accuracy, delimiter="\n")
print(np.mean(history.history["binary_accuracy"]))
result = model.predict(X ).round()
print (result)</pre>
<p><strong>定義input(X)和output(Y)</strong></p>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">X = np.array(([0,0,0],[0,0,1],[0,1,0], [0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]), dtype=float)
# X是三輸入XOR邏輯閘
y = np.array(([1], [0], [0], [0], [0], [0], [0], [1]), dtype=float)
# Y是輸出神經網路</pre>
<p><strong>setting</strong></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">model = tf.keras.Sequential() #sequential定義modle為層狀結構
model.add(Dense(4, input_dim=3, activation='relu', use_bias=True))
'''
add是從最上層開始加入，Dense是密集連線的神經網路，
4:輸出空間(神經元，輸出到4個神經元)，input_dim:輸入神經元個數，activation:定義啟動函數使用的類型，use_bias:使用偏差，True開啟。從inputlayer輸出到hiddenlayer的設定
'''

#model.add(Dense(4, activation='relu', use_bias=True))
model.add(Dense(1, activation='sigmoid', use_bias=True))
# 從hiddenlayer輸出到outputlayer的設定

model.compile(loss='mean_squared_error', optimizer='adam', metrics=['binary_accuracy'])
'''
配置訓練模組，loss funsion:用maen squared error(差平方誤差)，optimizer:優化器，
用adam function，metrics：計算準確率，用binary_accuracy
'''

print (model.get_weights())#印出回傳的正確權重
history = model.fit(X, y, epochs=2000, validation_data = (X, y))
'''
訓練模型給予固定epochs，迭代收集到的資料，validation_data：評估準確率(不包含在訓練裡面)
'''
</pre>
<p><strong>ReLU</strong><br/>max_value：輸出後最大值上限<br/>negative_slope：負斜率係數<br/>threshold：可通過的數值界線</p>
<p>[<a href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/ReLU">tf.keras.layers.ReLU | TensorFlow Core v2.4.0</a>]</p>
<p><strong>mean squared error(MSE)</strong></p>
<p><img caption="false" height="500" src="/images/MSE.png" width="508"/></p>
<p>(<a href="https://www.freecodecamp.org/news/machine-learning-mean-squared-error-regression-line-c7dde9a26b93/">圖片來源</a>)</p>
<p><img alt="" height="100" src="/images/MSE_Function.jpg" width="388"/></p>
<p>[<a href="https://www.khanacademy.org/math/statistics-probability/describing-relationships-quantitative-data/more-on-regression/v/proof-part-1-minimizing-squared-error-to-regression-line">Proof (part 1) minimizing squared error to regression line (video) | Khan Academy</a>]</p>
<p>[<a href="https://www.listendata.com/2018/03/regression-analysis.html">15 Types of Regression in Data Science</a>]</p>
<p>[<a href="https://www.tensorflow.org/api_docs/python/tf/keras/Sequential#compile">tf.keras.Sequential | TensorFlow Core v2.4.0</a>]</p>
<p>[<a href="https://www.freecodecamp.org/news/machine-learning-mean-squared-error-regression-line-c7dde9a26b93/">Machine learning: an introduction to mean squared error and regression lines</a>]</p>
<p>[<a href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Dense">tf.keras.layers.Dense | TensorFlow Core v2.4.0</a>]</p>
<p>[<a href="https://www.tensorflow.org/api_docs/python/tf/keras/losses">Module: tf.keras.losses | TensorFlow Core v2.4.0</a>]</p>
<p>[<a href="https://www.tensorflow.org/api_docs/python/tf/keras/optimizers">Module: tf.keras.optimizers | TensorFlow Core v2.4.0</a>]</p>
<p>[<a href="https://www.tensorflow.org/api_docs/python/tf/keras/metrics">Module: tf.keras.metrics | TensorFlow Core v2.4.0</a>]</p>
<p>[<a href="https://www.tensorflow.org/hub/api_docs/python/hub/KerasLayer?hl=fr#get_weights">hub.KerasLayer | TensorFlow Hub</a>]</p>
<p>[<a href="https://www.tensorflow.org/api_docs/python/tf/summary">Module: tf.summary | TensorFlow Core v2.4.0</a>]</p>
<p>[<a href="https://keras.io/api/layers/activations/">Keras documentation: Layer activation functions</a>]</p>
<p><strong>history</strong></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">model.summary()
# 摘要資料使用在分析和可視化，為了確認訓練架構在符合預期方向

loss_history = history.history["loss"]
#回傳紀錄事件(loss)到history物件，取得fit方法的模組回傳值
numpy_loss_history = np.array(loss_history)
#將loss_history數值存成array
np.savetxt("loss_history.txt", numpy_loss_history, delimiter="\n")
#將numpy_loss_history存成loss_history.txt，並將每筆資料用換行符號隔開

binary_accuracy_history = history.history["binary_accuracy"]
#回傳紀錄事件(binary_accuracy)到history物件
numpy_binary_accuracy = np.array(binary_accuracy_history)
#將binary_accuracy_history數值存成array
np.savetxt("binary_accuracy.txt", numpy_binary_accuracy, delimiter="\n")
#將numpy_binary_accuracy存成binary_accuracy.txt，並將每筆資料用換行符號隔開
</pre>
<p><br/><strong>result</strong></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">print(np.mean(history.history["binary_accuracy"]))
#印出平均binary_accuracy記錄到的數值
result = model.predict(X ).round()
#替輸入樣本產生輸出預測
print (result)
#印出結果</pre>
<p><a href="/downloads/整理資料/neural_network_in_python_summary.pdf">整理好的PDF檔</a></p>
<h2>參考範例</h2>
<p>參考範例 <br/><a href="https://github.com/mdecourse/4072pj1/blob/master/40723150/example/pong2.py">https://github.com/mdecourse/4072pj1/blob/master/40723150/example/pong2.py</a></p>
<h4>GPU運算</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">with cp.cuda.Device(0):#用GPU0做計算
    if resume:
        model = pickle.load(open('save.p', 'rb'))
        '''以 Binary 的方式讀取 save.p'''
        print('resuming')
    else:
        model = {}
        model['W1'] = np.random.randn(D,H) / np.sqrt(D) 
	'''W1檢測遊戲場景'''
        model['W2'] = np.random.randn(H,A) / np.sqrt(H)
	'''W2決定擊錘向上或向下移動'''
    grad_buffer = { k : np.zeros_like(v) for k, v in model.items() }
    # update buffers that add up gradients over a batch
    rmsprop_cache = { k : np.zeros_like(v) for k, v in model.items() }
    # rmsprop memory
</pre>
<p></p>
<p><span> python open()[來源：<a href="https://www.w3schools.com/python/ref_func_open.asp">w3schools</a>]</span></p>
<h4><span>sigmoid </span></h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def sigmoid(x): 
    return 1.0 / (1.0 + np.exp(-x))</pre>
<p>$$\sigma(x) = \frac{1}{1+e^{-x}}$$</p>
<h4>softmax</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def softmax(x):
    probs = np.exp(x - np.max(x, axis=1, keepdims=True))
    probs /= np.sum(probs, axis=1, keepdims=True)
    return probs</pre>
<p>$$\sigma(\overrightarrow{z})_i = \frac{e^{z_i}}{\sum^K_{j=1}e^{z_j}}$$</p>
<p style="text-align: right;">[來源：<a href="https://deepai.org/machine-learning-glossary-and-terms/softmax-layer">softmax</a>資料]</p>
<h4>prepro</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def prepro(I):
    """ prepro 210x160x3 uint8 frame into 6400 (80x80) 1D float vector """
    I = I[35:195] # 裁掉頂部的計分和底部空白，剩下160x160
    I = I[::2,::2,0] # 從160x160縮減到80x80，取出第一個顏色channel
    I[I == 144] = 0 # 將背景顏色變成黑色
    I[I == 109] = 0 # 將背景顏色變成黑色
    I[I != 0] = 1 # 球和擊錘變成白色
    return I.astype(np.float).ravel()</pre>
<h4>discount rewards</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def discount_rewards(r):
    """ take 1D float array of rewards and compute discounted reward """
    discounted_r = np.zeros_like(r) #和r矩陣相同維度大小的0矩陣
    running_add = 0
    for t in reversed(range(0, r.size)):
        if r[t] != 0: running_add = 0 
        # 當球到邊界的時候重設總和
        running_add = running_add * gamma + r[t]
        discounted_r[t] = running_add
		    '''加入第t項折扣'''
    return discounted_r</pre>
<h4>policy forward</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">def policy_forward(x):
    if(len(x.shape)==1):
        x = x[np.newaxis,...]

    h = x.dot(model['W1'])
    h[h&lt;0] = 0 # ReLU nonlinearity
    logp = h.dot(model['W2'])
    #p = sigmoid(logp)
    p = softmax(logp)

    return p, h 
    # return probability of taking action 2, and hidden state
    # h 是球在環境上的狀態，p 是移動的決策
</pre>
<h4>policy backward</h4>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">def policy_backward(eph, epdlogp):
    """ backward pass. (eph is array of intermediate hidden states) """
    dW2 = eph.T.dot(epdlogp)  
    dh = epdlogp.dot(model['W2'].T)
    dh[eph &lt;= 0] = 0 # backpro prelu

    t = time.time()
    # problem: https://github.com/chainer/chainer/issues/8582
    if(be == cp): #將參數複製到GPU或CPU
        dh_gpu = cuda.to_gpu(dh, device=0)
        epx_gpu = cuda.to_gpu(epx.T, device=0)
        dW1 = cuda.to_cpu( epx_gpu.dot(dh_gpu) )
        # 將GPU的矩陣複製到CPU
    else:
        dW1 = epx.T.dot(dh) 
    

    print((time.time()-t0)*1000, ' ms, @final bprop')

    return {'W1':dW1, 'W2':dW2}</pre>
<h4>訓練過程</h4>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">while True:
    t0  = time.time()
    #render = True
    if render: 
        t  = time.time()
        env.render()# 顯示訓練中狀況(影像)
        print((time.time()-t)*1000, ' ms, @rendering')
        # 計算每幀時間差

    t  = time.time()
    # preprocess the observation, set input to network to be difference image
    cur_x = prepro(observation)
    x = cur_x - prev_x if prev_x is not None else np.zeros(D)
    prev_x = cur_x
  
    # forward the policy network and sample an action from the returned probability
    t  = time.time()
    aprob, h = policy_forward(x)
    # roll the dice, in the softmax loss
    u = np.random.uniform()
    aprob_cum = np.cumsum(aprob)
    a = np.where(u &lt;= aprob_cum)[0][0]
    action = a+2
    #print(u, a, aprob_cum)
  
    # record various intermediates (needed later for backprop)
    t = time.time()
    xs.append(x) # observation
    hs.append(h) # hidden state

    #softmax loss gradient
    dlogsoftmax = aprob.copy()
    dlogsoftmax[0,a] -= 1 #-discounted reward 
    dlogps.append(dlogsoftmax)


    # step the environment and get new measurements
    t  = time.time()
    observation, reward, done, info = env.step(action)
    reward_sum += reward 

    drs.append(reward) # record reward (has to be done after we call step() to get reward for previous action)


    if done: # an episode finished
        episode_number += 1

        t  = time.time()

        # stack together all inputs, hidden states, action gradients, and rewards for this episode
        epx = np.vstack(xs)
        eph = np.vstack(hs)
        epdlogp = np.vstack(dlogps)
        epr = np.vstack(drs)
        xs,hs,dlogps,drs = [],[],[],[] # reset array memory

        print(epdlogp.shape)

        # compute the discounted reward backwards through time
        discounted_epr = discount_rewards(epr)
        # standardize the rewards to be unit normal (helps control the gradient estimator variance)
        discounted_epr -= np.mean(discounted_epr)
        discounted_epr /= np.std(discounted_epr)

        epdlogp *= discounted_epr # modulate the gradient with advantage (PG magic happens right here.)
        grad = policy_backward(eph, epdlogp)
        for k in model: grad_buffer[k] += grad[k] # accumulate grad over batch

        # perform rmsprop parameter update every batch_size episodes
        if episode_number % update_freq == 0: #update_freq used to be batch_size
            for k,v in model.items():
                g = grad_buffer[k] # gradient
                rmsprop_cache[k] = decay_rate * rmsprop_cache[k] + (1 - decay_rate) * g**2
                model[k] -= learning_rate * g / (np.sqrt(rmsprop_cache[k]) + 1e-5)
                grad_buffer[k] = np.zeros_like(v) # reset batch gradient buffer

        # boring book-keeping
        running_reward = reward_sum if running_reward is None else running_reward * 0.99 + reward_sum * 0.01
        print('resetting env. episode reward total was %f. running mean: %f' % (reward_sum, running_reward))
        if episode_number % 100 == 0: pickle.dump(model, open('save.p', 'wb'))
        reward_sum = 0
        observation = env.reset() # reset env
        prev_x = None
        
        print((time.time()-t)*1000, ' ms, @backprop')


    outstring =""

    if reward != 0: # Pong has either +1 or -1 reward exactly when game ends.
        if reward == -1:
            outstring = ''
        else:
            outstring = '!!!!!!!'
        
        print ('ep '+ str(episode_number) + ': game finished, reward:' +str(reward)+ outstring )</pre>
<h4>訓練結果</h4>
<p>紅點是每局的獎勵總和，藍色是累積獎勵平均值。橫軸：訓練局數；縱軸獎勵分數。</p>
<p><img caption="false" height="500" src="/images/pong2_41k.png" width="667"/></p>
<h2>Markov</h2>
<h4>Markov Chain</h4>
<p>當前決策只會影響下個狀態，當前狀態轉移(action)到其他狀態的機率有所差異。</p>
<h4>Markov Reward Process</h4>
<p>action 到指定狀態會獲得獎勵。</p>
<p>$$R(s_t=s) = \mathbb{E}[r_t|s_t = s]$$</p>
<p>$$\gamma \in [0, 1]$$</p>
<ul style="list-style-type: disc;">
<li><span>Horizon：<br/>在無限的狀態以有限的狀態表示</span></li>
<li><span>Return：<br/>越早做出正確決策獎勵越高</span><span></span><span><br/>$$G_t = R_{t+1}+\gamma R_{t+2}+\gamma^2 R_{t+3}+\gamma^3 R_{t+4}+...+\gamma^{T-t-1} R_{T}$$</span><span><br/></span></li>
<li><span>State value function：<br/>決策價值</span><span><br/>$$V_t(S) = \mathbb{E}[G_t|s_t = s]$$</span><span><br/></span></li>
</ul>
<h4><span>Discount Factor (γ)</span></h4>
<ol>
<li>越早做出有獎勵的決策，獎勵越高</li>
<li>做出有價值的決策 $\gamma = 1$，不分決策順序先後</li>
<li><span>無用的決策C= 0，不會得到獎勵</span><span></span></li>
</ol>
<p><span>Bellman equation：描述互動關係狀態</span></p>
<p><span>$$V(s) = R(s)+\gamma\sum_{s'\in S}P(s'|s)V(s')$$</span></p>
<p><span>$$R(s):立即獎勵$$</span></p>
<p><span>$$\gamma\sum_{s'\in S}P(s'|s)V(s')：未來獎勵衰減總和$$<br/></span></p>
<p style="text-align: left;"><span><span>Anaytic solution ：分析性解法<br/>MRP的分析性解法：</span></span></p>
<p style="text-align: left;"><span><span>$$V = (1-\gamma P)^{-1}R$$</span></span></p>
<p style="text-align: left;"><span><span>只適合小的MRP(個數比較少的)，</span></span><span><span>矩陣複雜度為$O(N^3)$，N為狀態個數</span></span></p>
<p style="text-align: left;"><span><span>計算大型MRP會使用疊代法：</span></span></p>
<ol>
<li style="text-align: left;"><span><span>動態規劃(Dynamic programming)</span></span></li>
<li style="text-align: left;">Mote-Carlo evaluation<br/>以評估採樣的方式<br/>$$g = \sum_{i=t}^{H-1}\gamma^{1-t}r_i$$<br/>$$G_t \leftarrow G_t+g,  i \leftarrow i+1$$<br/>$$V_t(s) \leftarrow \frac{G_t}{N}$$</li>
<li style="text-align: left;">Temporal-Difference learning</li>
</ol>
<h3>Markov Decision Process</h3>
<p>在MRP中加入決策(decision)和動作(action)</p>
<ul>
<li>S：state 狀態</li>
<li>A：action 動作</li>
<li>P：狀態轉換<br/>$$P(s_{s+1}=s'|s_t=s,a_t=a)$$</li>
<li>R：獎勵，取決於當前狀態和動作會得到相對應的講勵<br/>$$ R(s_t=s, a_t=a) = \mathbb{E}[r_t|s_t, a_t=a] $$</li>
<li>D：折扣因子(discount factor)<br/>$$\gamma \in [0,1]$$</li>
</ul>
<p>MDP is a tuple：(S, A, P, R, $\gamma$)</p>
<p>policy (決策)：可以是一個決策行為機率或確定行為</p>
<p>$$\pi (a|s) = P(a_t=a|s_t=s)$$</p>
<p>MRP 和 MDP 轉換</p>
<table style="margin-left: auto; margin-right: auto; width: 477px;">
<tbody>
<tr style="height: 42px;">
<td style="width: 202.667px; text-align: center; height: 42px;">MRP</td>
<td style="width: 29.3333px; text-align: center; height: 42px;">↔</td>
<td style="width: 223.333px; text-align: center; height: 42px;">MDP</td>
</tr>
<tr style="height: 40px;">
<td colspan="3" style="width: 467.333px; text-align: center; height: 40px;">$P^{\pi}(s's) = \sum_{a\in A}\pi (a|s)P(s'|s, a)$</td>
</tr>
<tr style="height: 43px;">
<td colspan="3" style="width: 467.333px; text-align: center; height: 43px;">$P^{\pi}(s) = \sum_{a\in A}\pi (a|s)P(s, a)$</td>
</tr>
<tr style="height: 98.7292px;">
<td style="width: 202.667px; text-align: center; height: 98.7292px;">
<p><img caption="false" height="150" src="/images/MRP.jpg" width="251"/></p>
<p>圖1.MRP</p>
</td>
<td style="width: 29.3333px; text-align: center; height: 98.7292px;"></td>
<td style="width: 223.333px; text-align: center; height: 98.7292px;">
<p><img alt="" height="150" src="/images/MDP.jpg" width="218"/></p>
<p>圖2.MDP</p>
</td>
</tr>
</tbody>
</table>
<h4>state value function(狀態值方程式) $v^{\pi}(s)$</h4>
<p>$$v^{\pi}(s) = \mathbb{E}[G_t|s_t=s]$$</p>
<p>$$= \mathbb{E}[R_{t+1}+\gamma v^{\pi}(s_{t+1})|s_t=s]$$</p>
<p>$$= \sum_{a\in A}\pi (a|s)q^{\pi}(s, a)$$</p>
<p style="text-align: center;"><img alt="" height="200" src="/images/s_to _s.jpg" width="315"/></p>
<p style="text-align: center;">圖3.Backup Diagram for $V^{\pi}$</p>
<p style="text-align: left;"><span>$$v^{\pi}(s) = \sum_{a\in A}\pi (a|s)(R(s, a)+\gamma \sum_{s'\in s}P(s'|s, a)v^{\pi}(s'))$$</span></p>
<h4>action value function(行為方程式)$q^{\pi}(s, a)$</h4>
<p>$$q^{\pi}(s, a) = \mathbb{E}[G_t|s_t=s, A_t=a]$$</p>
<p>$$= \mathbb{E}[R_{t+1}+\gamma q^{\pi}(s_{t+1}, A_{t+1})|s_t=s, A_t=a]$$</p>
<p>$$= R^a_s+\gamma \sum_{s'\in s}P(s'|s)v^{\pi}(s')$$</p>
<p><span>$$= R(s, a)+\gamma \sum_{s'\in s}P(s'|s) \sum_{a'\in A}\pi (a'|s')q^{\pi}(s', a')$$</span></p>
<p style="text-align: center;"><span><img alt="" height="200" src="/images/Q_pi function.jpg" width="291"/></span></p>
<p style="text-align: center;"><span>圖4.Backup Diagram For $Q^{\pi}$</span></p>
<p><span>$$q^\pi(s, a)=R(s, a)+\gamma\sum_{s'\in S}P(s'|s, a)\sum_{a'\in A}\pi(a'|s')q^{\pi}(s', a')$$</span></p>
<h1>優化器</h1>
<p>為了讓AI學習的錯誤率降低，因此利用優化器來降低loss function的值，在error surface上找到最小值，即是找到錯誤率最低的地方。以下將介紹幾種優化的方法：</p>
<h4>Gradient Descent</h4>
<p>利用梯度的方式尋找最小值的位置，其特色可找到凸面error surface的絕對最小值，在非凸面error surface上找到相對最小值。其缺點是在非凸面error surface要避免被困在次優的局部最小值。</p>
<h4>Batch gradient descent</h4>
<p>用批次的方式計算訓練資料，整個資料集計算梯度只更新一次，因此計算和更新時會占用大量記憶體。整體效率較差、速度較緩慢。由 Gradient Descent 延伸出來的算法。其收斂行為與<span> Gradient Descent 相同。</span></p>
<h4>Stochastic gradient descent</h4>
<p>每次執行時會更新並消除誤差，有頻繁更新和變化大的特性，較不容易困在特定區域。<span>由 Gradient Descent 延伸出來的算法。其收斂行為與</span><span> Gradient Descent 相同。</span></p>
<h4>Mini-batch gradient descent</h4>
<p>結合 Batch gradient descent 和 Stochastic gradient descent 的特點：批量計算和頻繁更新，所衍伸的算法。利用小批量的方式頻繁更新，並使收斂更穩定。其缺點：學習率挑選不易、預定義 threshold 無法適應數據集的特徵、對很少發生的特徵無法執行較大的更新、<span>非凸面error surface要避免被困在次優的局部最小值等。</span></p>
<h4>Gradient descent optimization algorithms</h4>
<p>為了改善前面幾種算法而發展出來的優化算法。以下將列出數種優化算法。</p>
<h4>Momentum</h4>
<p>在梯度下降法加上動量的概念，會加速收斂到最小值並減少震盪。</p>
<h4>Nesterov accelerated gradient</h4>
<p>NAG，有感知能力的 Momentum：在坡度變陡時減速，避免衝過最小值所造成的震盪(為了修正到最小值，來回修正而產生的震盪)</p>
<h4>Adagrad</h4>
<p>其學習率能適應參數：<span>頻繁出現的特徵用較低的學習率，不經常出現的特徵則用較高的學習率，且無須手動調整學習率。其缺點是，學習率會急遽下降，最後會無限小，這算法就不再獲得知識。</span></p>
<h4><span>Adadelta</span></h4>
<p><span>為 Adagrad 的延伸，下降激進程度，學習率從更新規則中淘汰，不需設定預設學習率。</span></p>
<h4>RMSprop</h4>
<p><span>為了解決 Adagrad 學習率急劇下降的問題，學習率除以梯度平方的RMS，解決學習率無限小的情形。</span></p>
<h4>Adam</h4>
<p><span>類似 Momentum，更加穩定快速的收斂。</span></p>
<h4>AdaMax</h4>
<p><span><span>與 Adam 相似，依靠 (u_t)<span><span> </span></span>最大運算</span></span></p>
<h4>Nadam</h4>
<p><span>結合 Adam 和 NAG ，應用先前參數執行兩次更新，一次更新參數一次更新梯度。</span></p>
<h4>AMSGrad</h4>
<p>改善 Adam 算法所導致收斂較差的情況(用指數平均會減少其影響)，換用梯度平方最大值來做計算，並移除去偏差的步驟。是否有比 <span>Adam 算法好仍有待觀察。</span></p>
<h4>Gradient noise</h4>
<p><span>有助於訓練特別深且復雜的網絡，noise 可改善不良初始化的網路。</span></p>
<p><strong><a href="/downloads/整理資料/神經網路梯度下降優化法.pdf">神經網路優化器算法整理</a></strong></p>
<h2>Gradient Descent Optimizer</h2>
<p>(<a href="https://hackernoon.com/the-reason-behind-moving-in-the-direction-opposite-to-the-gradient-f9566b95370b">資料來源</a>)</p>
<p style="text-align: center;"><strong><img alt="Error_surface" caption="false" height="200" src="/images/Error_surface.png" width="231"/></strong></p>
<p style="text-align: center;"><strong>圖1. Error_surface<sub>(<a href="https://hackernoon.com/the-reason-behind-moving-in-the-direction-opposite-to-the-gradient-f9566b95370b">圖片來源</a>)</sub></strong></p>
<p>藉由梯度下降將目標函數值最小化，目標函數以loss function $L(\theta)$為例，$\theta$為weight $(w)$ 和 bias $(b)$ 的向量函數，為了找到error surface(圖1)上的最小值，因此加上$\Delta\theta$ 將$\theta$的方向修正並引導到正確方向，避免每次修正的過多導致錯過最小值，利用係數$\eta$(學習率)縮放<span>$\Delta\theta$的修正量(圖2)，修正後方程式為：</span></p>
<p style="text-align: center;">$$\theta=\theta+\eta\cdot\Delta\theta$$</p>
<p style="text-align: center;"><span><img alt="theta_vector" caption="false" height="193" src="/images/theta_vector.png" width="297"/></span></p>
<p style="text-align: center;"><span><strong>圖2. Theta_vector<sub>(<a href="https://hackernoon.com/the-reason-behind-moving-in-the-direction-opposite-to-the-gradient-f9566b95370b">圖片來源</a>)</sub></strong></span></p>
<p><span></span>將<span>$\theta$以<a href="https://youtu.be/3d6DsjIBzJ4">泰勒展開式</a>表示，假設並$\Delta\theta$為u:</span></p>
<p style="text-align: center;">$$L_{(\theta+\eta u)}=L_{(\theta)}+\eta u^{T}\cdot\bigtriangledown_{\theta} L_{(\theta)}+\frac{\eta^2}{2!}u^T\cdot\bigtriangledown^2 L_{(\theta)}u+\frac{\eta^3}{3!}...+\frac{\eta^4}{4!}...+\frac{\eta^n}{n!}...$$</p>
<p style="text-align: left;">以泰勒展開式的型式表示的好處是： $\theta$ 些微的更動產生新值。$\eta$ 值通常小於一，當 $\eta^2 &lt;&lt; 1$，因此可以忽略高階項 </p>
<p style="text-align: center;">$$L_{(\theta+\eta u)}=L_{(\theta)}+\eta u^{T}\cdot\bigtriangledown_{\theta} L_{(\theta)} [\eta\ is\ typically\ small, so\ \eta^2, \eta^3,\cdots \rightarrow 0]$$</p>
<p style="text-align: left;"><span>新的$ L(\theta + \eta u)$ 輸出的值會小於$ L(\theta) L(\theta+\eta u) − L(\theta) &lt; 0$，同理可證 $u^T\cdot\bigtriangledown\theta L(\theta)$ &lt; 0，符合u這條件：當新的值小於舊的值，u就是一個好的值。假設u和$\bigtriangledown\theta L(\theta)$ 的夾角為$\href{https://www.khanacademy.org/math/linear-algebra/vectors-and-spaces/dot-cross-products/v/vector-dot-product-and-vector-length}{\underline{\beta}}$ </span></p>
<p style="text-align: center;">$$\cos(\beta)=\frac{u^{T}\cdot\bigtriangledown_{\theta} L_{(\theta)}}{\vert u^{T}\vert\vert \bigtriangledown_{\theta} L_{(\theta)}\vert}$$</p>
<p style="text-align: left;"><span>因為 $\cos(\theta)$ 的值介於 1 和-1 之間</span></p>
<p>$$-1&lt;\cos(\beta)=\frac{u^{T}\cdot\bigtriangledown_{\theta} L_{(\theta)}}{\vert u^{T}\vert\vert \bigtriangledown_{\theta} L_{(\theta)}\vert}\leq 1$$</p>
<p>$$k=\vert u^{T}\vert\vert \bigtriangledown_{\theta} L_{(\theta)}\vert $$<br/>$$-k \leq k\cos(\beta)=u^{T}\cdot\bigtriangledown_{\theta} L_{(\theta)}\leq k$$</p>
<p style="text-align: left;"><span>所以盡可能的讓新值小於舊值 $(L(\theta+\eta u) − L(\theta) &lt; 0)$，loss 值就會減少得越多。因此 $u T \cdot \bigtriangledown\theta L(\theta)$ 應該為負，在 這情況下 $\cos(\beta)$ 等於 −1，$\beta$ 的角度為 180<sup>◦</sup>，這就是$\theta$移動的方向與梯度方向相反的原因。 梯度下降法告訴我們：當 $\theta$ 在特定值，並想減少新的 $\theta$ 值，使 loss 值逐漸減少就應該與梯度相反的方向找 (若梯度為正值，找最小值就需往負的方向找) </span></p>
<p style="text-align: center;">$w_{t=1}=w_t-\eta\bigtriangledown w_t$<br/>$b_{t=1}=b_t-\eta\bigtriangledown b_t$<br/>$where\ at\ w=w_t,b=b_t$<br/>$<br/> \begin{cases}<br/> \bigtriangledown w_t=\frac{\partial L_{_{(\theta)}}}{\partial w}\\<br/> \bigtriangledown b_t=\frac{\partial L_{_{(\theta)}}}{\partial b}<br/> \end{cases}<br/>$</p>
<h2>Stochastic gradient descent</h2>
<p>(<a href="https://ruder.io/optimizing-gradient-descent/">資料來源</a>)</p>
<h4><span>Batch gradient descrnt</span></h4>
<p><span>Vanilla gradient descent 又稱 Batch gradient descent(批次梯度下降法)，計算目標函數的梯度，參數 θ 對於整個 訓練資料：</span></p>
<p>$$\theta=\theta-\eta\cdot\bigtriangledown_{\theta}L_{(\theta)}$$</p>
<p>目標函數以為例 loss function L(θ)，參數 $\theta$為 weight (w) 和 bias (b) 的函數，$\eta$為學習率。由於計算整個資料集計算梯度只更新一次，Bath gradient descent 可能非常慢並且對於資料集無法符合及記憶體來說棘手 (一次需要儲存整個資料集的資料，當更新和計算時會占用大量記憶體)。<span></span></p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">for i in range(nb_epochs) :
params_grad = evaluate_gradient (loss_function, data, params)
params = params − learning_rate ∗ params_grad
</pre>
<p style="text-align: center;">程式1. Batch gradient descrnt <sub><span>(</span><a href="https://ruder.io/optimizing-gradient-descent/">程式來源</a><span>)</span></sub></p>
<p>預定義每次 epoch，先計算 loss function 梯度向量對於整個資料集參數向量。如果梯度值來自於先前計算出的梯度值，就會檢查梯度，並以梯度相反的方向更新參數$\theta$，學習率$\eta$決定多大的更新量。Batch gradient descent 對於凸面誤差可以保證收斂到廣域最小值，對於非面凸誤差可以收斂到局部最小值。</p>
<h4>Stochastic gradient descent</h4>
<p>Stochastic gradient descent(SGD) 隨機梯度下降法，這裡的目標函數為 $J(\theta, x^i, y^i)$(變數 $\theta$ 為 w(weight) 和 b(bias) 的函數，也可以寫成 $ J(w,b,\theta, x^i, y^i)$<span>)</span>。</p>
<p>$$\theta=\theta-\eta\cdot\bigtriangledown_{\theta}J_{(\theta, x^i, y^i)}$$</p>
<p>批量梯度下降他會在每個參數更新前重新計算相似梯度。SGD 每次次執行會更新來消除多餘 (誤差)，因此通常速度 很快。SGD 頻繁更新並變化很大，因為目標方程式波動很大 (圖1)。</p>
<p style="text-align: center;"><img alt="" height="300" src="/images/sgd_fluctuation.png" width="382"/></p>
<p style="text-align: center;">圖1.SGD fluctuation <sub>(<a href="https://ruder.io/optimizing-gradient-descent/">圖片來源</a>)</sub></p>
<p>SGD 的方程式一方面會跳到新的值和潛在局部最小值，另一方面 SGD 會持續超調 (誤差超過預期) 最後收斂到廣域最小值。無論如何他被顯示當學習率下降緩慢，SGD 顯示與 Batch gradient descent 同樣收斂行為，幾乎可以肯定地，對於凸面或非凸面優化，會收斂到絕對或是局部最小值。這程式碼片段 (程式.2) 在訓練樣本上加入一個迴圈來對每個樣本評估梯度。每個 epoch(訓練循環) 會打亂訓練數據。</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">for i in range(nb_epochs) :
np.random.shuffle(data)
for example in data :
params_grad = evaluate_gradient (loss_function, example, params)
params = params − learning_rate ∗ params_grad</pre>
<p style="text-align: center;"><span>程式2. Stochastic gradient descrnt <sub>(<a href="https://ruder.io/optimizing-gradient-descent/">程式來源</a><span>)</span></sub></span></p>
<h4>Mini-batch gradient descent</h4>
<p>Mini-batch gradient descent(小批量梯度下降) 各取前兩者的優點，將資料集分割成小區塊，每個小區塊大小稱作 batch size，每次跑完 batch size 算迭代 (iteration)一次，算完一次資料集即完成一次 epoch。舉例: 資料集大小為 1000，若 batch size 為 50，iteration 為 datasets 的 batch_size = 1000÷50 = 20，當 iteration 跑完 20 次算完成一次 epoch。</p>
<p>這方式可以減少參數更新的方差，並且可以穩定收斂；可利用深度學習庫所共有的高度優化的矩陣優化，從而由一個小批量計算出梯度非常有效。通常 batch sizes 的範圍介於 50 ~256，會因為應用而有所差異。訓練神經網絡時，通常選擇 Mini-batch gradient descent 算法，而當使用這算法時，通常也用 SGD 稱呼。</p>
<p><span>$$\theta=\theta-\eta\cdot\bigtriangledown_{\theta}J_{(\theta, x^{(i:i+n)}, y^{(i:i+n)})}$$</span></p>
<p>下面程式碼 (程式.3) 為迭代範例，batch size 大小為 50：</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">for i in range(nb_epochs ) :
np.random.shuffle(data)
for batch in get_batches (data, batch_size = 50):
params_grad = evaluate_gradient (loss_function, batch, params)
params = params − learning_rate ∗ params_grad
</pre>
<p style="text-align: center;"><span>程式3. <span>Mini-batch</span> gradient descrnt <sub>(<a href="https://ruder.io/optimizing-gradient-descent/">程式來源</a><span>)</span></sub></span></p>
<h4>Challenges</h4>
<p>Mini-batch gradient descent 無論如何還是無法確保收斂的很好，存在一些需要解決的挑戰：</p>
<ol>
<li>選擇適當的學習率是有難度的。如果學習率太小會導致收斂困難或緩慢，學習率太大則會阻礙收斂導致 loss function 來回波動或發生偏離。</li>
<li> 學習率清單嘗試在訓練的時候調整學習率，即根據預定義清單或當目標下降於閾值 (threshold) 時降低學習率。 但清單和閾值須預先定義，因此無法適應數據集的特徵。</li>
<li> 另外相同學習率適用全部參數更新。如果資料稀疏而且外型有很特別的頻率，我們可能不希望將所有特徵更新 到相同的程度，而是對很少發生的特徵執行較大的更新。</li>
<li> 最小化神經網路常見的高度非凸面誤差方程式<span> (error function) </span>的另一關鍵挑戰則是要避免被困在大量次優的局 部最小值區域中。認為困難實際上不是由局部最小值引起的，而是由鞍點引起的，即一維向上傾斜而另一維向下 傾斜的點。這些鞍點通常被相同誤差的平穩段包圍，這使得 SGD 很難逃脫，因為在所有維度上梯度都接近於零。</li>
</ol>
<h2>Gradient descent optimization algorithms</h2>
<p><span>(</span><a href="https://ruder.io/optimizing-gradient-descent/">資料來源</a><span>)</span></p>
<h4>Momentum</h4>
<p>SGD 難以在陡峭的往正確的方向，那就是說在一個維度上，曲面的彎曲比另一個維度要陡得多，這在局部最優情況下很常見。下圖(圖.1)的同心圓代表中心下凹的曲面。在這些情況下，SGD 會在陡峭的地方振盪，而僅沿著底部朝著局部最優方向猶豫前進，如 (圖.1.a) 所 示。 Momentun(動量) 是一個幫助加速 SGD 在正確方向和抑制震盪的方法，在 (圖.1.b)。</p>
<table style="width: 250.667px; margin-left: auto; margin-right: auto;">
<tbody>
<tr>
<td style="width: 236px;"><img alt="without_momentum" caption="false" height="100" src="/images/without_momentum.png" width="236"/></td>
<td style="width: 10px;"><img alt="with_momentum" caption="false" height="100" src="/images/with_momentum.png" width="236"/></td>
</tr>
<tr>
<td style="width: 236px; text-align: center;"><span> 圖.1.</span>a <br/>SGD without momentum</td>
<td style="width: 10px; text-align: center;"><span>圖.1.</span>b <br/>SGD with momentum </td>
</tr>
<tr>
<td style="width: 236px; text-align: center;"><span></span></td>
<td style="width: 10px; text-align: right;"><sub><span>(<a href="https://ruder.io/optimizing-gradient-descent/">圖片來源</a>)</span></sub></td>
</tr>
</tbody>
</table>
<p><br/>這麼做會增加一個係數 $\gamma$ (gamma) 來更新上次的向量到正確向量 (修正偏差)，$\gamma$ 通常設為 0.9 左右。</p>
<p style="text-align: left;">$$v_t = \gamma v_{t-1}+\eta\cdot\bigtriangledown_{\theta}J_{(\theta)}$$</p>
<p style="text-align: left;">$$\theta = \theta-v_t$$</p>
<p style="text-align: left;">實際上，使用動量的時候，就像將球推下山坡。球在下坡時滾動時會累積動量，在途中速度會越來越快（如果存在空氣阻力，直到達到極限速度，也就是 $\gamma &lt; 1$) 參數更新也發生了同樣的事情：動量 (momentum) 對於梯度指向相同方向的維度增加，而對於梯度改變方向的維減少動量。結果，我們獲得了更快的收斂並減少了振盪。</p>
<h4 style="text-align: left;">Nesterov accelerated gradient</h4>
<p>Nesterov accelerated gradient（NAG）是一種使動量具有一個去向的概念，以便在山坡再次變高之前知道它會減速。我們知道使用動量 $\gamma v_{t-1}$ 來移動參數。計算 $\theta - \gamma v_{t-1}$ 這樣就給了參數的下一個位置的近似值（完整更新缺少的梯度），這是參數將要存在的大致概念。現在，通過計算與當前參數無關的梯度來有效地看到目前的參數 $theta$ 將會移動到的位置：</p>
<p style="text-align: left;">$$v_t = \gamma v_{t-1}+\eta\cdot\bigtriangledown_{\theta}J_{(\theta-\gamma v_{t-1})}$$</p>
<p style="text-align: left;">$$\theta = \theta - v_t$$</p>
<p style="text-align: center;"><sub><img alt="" height="100" src="/images/NAG.jpg" width="345"/></sub></p>
<p style="text-align: center;">圖.2 NAG <sub>(<a href="http://www.cs.toronto.edu/~tijmen/csc321/slides/lecture_slides_lec6.pdf">圖片來源</a>)</sub></p>
<p>同樣，我們設置動量 $\gamma$ 約為 0.9。動量首先計算當前梯度（(圖.2) 中的藍色小向量），然後在更新的累積梯度（藍 色向量）的方向上發生較大的跳躍，而 NAG 首先在先前的累積梯度的方向上進行較大的跳躍（棕色向量），測量梯度，然後進行校正（紅色向量），從而完成 NAG 更新（綠色向量）。這種預期的更新可防止我們過快地進行，並導致響應速度增加，從而顯著提高了 RNN 在許多任務上的性能。有關 NAG 背後另一解釋，請<a href="https://cs231n.github.io/neural-networks-3/">參見此處</a>，而 Ilya Sutskever 在其博士論文中給出了更詳細的概述。</p>
<h4>Adagrad</h4>
<p>Adagrad 是一個梯度優化的算法，它可以做到：學習率適應參數，對於頻繁出現的特徵相關參數執行較小的更新(較低的學習率)，以及對不經常出現的特徵相關參數進行較大更新（即學習率較高）。Adagrad 可以提高 SGD 的強度，用於訓練大型神經網絡。</p>
<p>先前，在同一次 $theta$ 參數(更新後就算另一次)，每個 $theta$ 都使用相同的 $\eta$ (學習率)。Adagrad 則是對每個 $theta$ 參數使用 不同的 $\eta$，t 代表 time step。先將 Adagrad 的更新參數向量化。用 $g_t$ 表示 time step 的梯度，$g_{t,i}$ 表示目標函數 (參數 $theta$ 在 time step t) 對參數做偏微分計算。</p>
<p style="text-align: left;">$$g_{t,i}=\bigtriangledown_{\theta}J_{(\theta_{t,i})}$$</p>
<p>當 SGD 更新每個參數 $\theta_i$，在每個 time step t，因此變成：</p>
<p>$$\theta_{t+1,i}=\theta_{t,i}-\eta\cdot g_{t,i}$$</p>
<p>更新規則，Adagrad 根據先前 <span>$\theta_i$</span> 計算的梯度，對每個參數 <span>$\theta_i$</span> 修改整個學習率 $\eta$ 在每個 time stept：</p>
<p>$$\theta_{t+1,i}=\theta_{t,i}-\frac{\eta}{\sqrt{G_{t,ii}+\epsilon}}$$</p>
<p>$G_t \in \mathbb{R}^{d\times d}$ 這是一個對角矩陣每個對角元素 i，i 是關於 $theta$ 梯度平方和取決於 time stept，$\epsilon$ 是避免分母為0($\epsilon$ 通常 為 $10^{-8}$ )，如果沒有平方根運算，該算法的性能將大大降低。 $G_t$ 包含了過去梯度平方根，由於全部 $theta$ 參數沿著對角線，通過向量的內積計算 $G_t$ 和 $g_t$：</p>
<p>$$\theta_{t+1}=\theta_{t}-\frac{\eta}{\sqrt{G_{t}+\epsilon}}\cdot g_t$$</p>
<p>Adagrad 主要好處之一是，無需手動調整學習率。大多數實現使用預設值 0.01 並將其保留為預設值。Adagrad 主 要弱點是會累積分母的平方梯度：由於每項都是正的，累積和會在訓練中不斷增長。反過來，學習率下降，並最終變 得無限小，這算法就不再獲得知識。</p>
<h4><span>Adadelta</span></h4>
<p>Adadelta 是 Adagrad 的延伸，下降其激進的程度，單調的降低學習率。Adadelta 會限制過去累積的梯度，並將其 限制在某個特定大小 w，並代替 Adagrad 過去累積的梯度平方，以梯度總和是遞迴定義為所有過去衰減梯度平方平均值。流動平均 $E[g^2]_t$ 在 time step t 然後取決於 (像 Momentum 的 $\gamma$) 先前 平均和最近梯度：</p>
<p>$$E[g^2]_t=\gamma E[g^2]_{t-1}+(1-\gamma)g^2 _t$$</p>
<p>$\gamma$ 值和 Momentum 的相似，約為 0.9，現在根據參數更新向量 $\bigtriangleup\theta_t$ 來重寫 SGD：</p>
<p>$$\bigtriangleup\theta_t=-\eta\cdot g_{t,i}$$</p>
<p>$$\theta_{t+1}=\theta_t+\bigtriangleup\theta_t$$</p>
<p>Adagrad 的參數更新向量替換成：對角矩陣 G<sub>t</sub> 過去梯度平方的衰退平均 <span>$E[g^2]_t$ </span></p>
<p>$$\bigtriangleup\theta_t=-\frac{\eta}{\sqrt{G_t+\epsilon}}\cdot g_t$$</p>
<p>$$replace\ G_t\ with\ E[g^2]_t\Rightarrow\bigtriangleup\theta_t=-\frac{\eta}{\sqrt{E[g^2]_t+\epsilon}}\cdot g_t$$</p>
<p>由於分母只是梯度的均方根 (RMS)，我們可以取代成縮寫：</p>
<p>$$\bigtriangleup\theta_t=-\frac{\eta}{RMS[g]_t}\cdot g_t$$</p>
<p>這個更新單位和 SGD、Momentum 以及 Adagrad 的單位不符合，因此更新需有相同的參數。為了實現這一點，首先定義另一個指數衰減平均值，這次不是梯度平方更新而是參數平方更新：</p>
<p>$$E[\bigtriangleup\theta^2]_t=\gamma E[\bigtriangleup\theta^2]_{t-1}+(1-\gamma)\bigtriangleup\theta^2 _t$$</p>
<p>RMS 參數更新:</p>
<p>$$RMS[\bigtriangleup\theta]_t=\sqrt{E[\bigtriangleup\theta^2]_t+\epsilon}$$</p>
<p>$RMS[\bigtriangleup\theta]_t$ 是未知的，更新參數的 RMS 取近似值到上個 time step。用 $RMS[\bigtriangleup\theta]_t$ 取代學習率 $\eta$，最後產生新 的規則：</p>
<p>$$\bigtriangleup\theta_t=-\frac{RMS[\bigtriangleup\theta]_{t-1}}{RMS[g]_t}g_t$$<br/>$$\theta_{t+1}=\theta_t+\bigtriangleup\theta_t$$</p>
<p>使用 Adadelta，甚至不需要設定預設學習率，因為它已從更新規則淘汰。</p>
<h4>RMSprop</h4>
<p>RMSprop 是 Geoffrey Hinton 在他的課程中提出的未公開自適應學習率的方法。</p>
<p>RMSprop 和 Adadelta 都是為了解決 Adagrad 的學習率急劇下降的問題個別獨立開發出來的解決方式。RMSprop 實際上與 Adadelta 得出的第一個更新向量相同：</p>
<p>$$E[g^2]_t=0.9E[g^2]_t+0.1g^2 _t$$</p>
<p>$$\theta_{t+1}=\theta_t-\frac{\eta}{\sqrt{E[g^2]_t+\epsilon}}g_t$$</p>
<p>RMSprop 也將學習率除以梯度平方的指數衰減平均值。Hinton 建議 $\gamma$ 設為 0.9，好的預設學習率 $\eta$ 數值為 0.001。</p>
<h4>Adam</h4>
<p>Adaptive Moment Estimation 自適應矩評估 (Adam) 是另一種計算每個評估學習率的方法。出了儲存過去梯度平 方的指數衰減平均值 $v_t$，就像 Adadelta 和 RMSprop 一樣，Adam 還保留過去梯度的指數衰減平均值 $m_t$，類似動量 (Momentum)。如果 Momentum 被視為順著斜坡下滑的球，而 Adam 則是像一個帶有摩擦的沉重的球，因此更適合待在 error face 平坦的最小值區域。計算過去梯度平方的衰減平均值 $m_t$ 和 $v_t$ 分別如下：</p>
<p>$$m_t=\beta_1 m_{t-1}+(1-\beta_1)g_t$$</p>
<p>$$v_t=\beta_2 v_{t-1}+(1-\beta_2)g^2 _t$$</p>
<p><span>$m_t$</span> 和 <span>$v_t$</span> 分別是第一階矩平均估計值和第二階矩無中心方差估計值，因此是方法的名稱。像 <span>$m_t$</span> 和 <span>$v_t$</span><sub> </sub>被初始化為向量 o，Adam 的作者觀察到它們偏向零，特別是在初始 time step，尤其是在衰減率較小的時候 (也就是說 $\beta_1$ 和 $\beta_2$<span><span> </span></span>趨近於 1) 藉由計算校正偏差第一矩 $\hat{m}_t$<sub> </sub>和第二矩 $\hat{v}_t$<em class="ph i"><sub> </sub></em>抵消偏差：</p>
<p>$$\hat{m}_t = \dfrac{m_t}{1 - \beta^t_1} $$</p>
<p>$$\hat{v}_t = \dfrac{v_t}{1 - \beta^t_2} $$</p>
<p>使用他們去更新參數，就像 Adadelta 和 RMSprop 中所看到的那樣，這將產生 Adam 更新規則：</p>
<p>$$\theta_{t+1} = \theta_{t} - \dfrac{\eta}{\sqrt{\hat{v}_t} + \epsilon} \hat{m}_t$$</p>
<p><span>$\beta_1$</span> 預設值建議為 0.9，<span>$\beta_2$</span> 預設值建議為 0.999，ϵ 預設值建議為 <span>$10^{-8}$</span>。根據經驗證明 Adam 表現良好，並且與其他自適應學習算法相比具有優勢。</p>
<h4>AdaMax</h4>
<p>在 Adam 更新規則中的 <span>$v_t$</span> 係數是與梯度成反比地縮放過去梯度的範數 (通過 <span>$v_{t-1}$</span> 項) 和當前梯度 $|g_t|^2$<sup> </sup>：</p>
<p>$$v_t = \beta_2 v_{t-1} + (1 - \beta_2) |g_t|^2$$</p>
<p>我們轉換這個更新到 $\ell_p$。注意$\beta_2$參數化為$\beta_2^p$：</p>
<p>$$v_t = \beta_2^p v_{t-1} + (1 - \beta_2^p) |g_t|^p$$</p>
<p>大規範 p 值使數值上變得不穩定，這就是為什麼 $\ell_1$ 和 $\ell_2$ 規範在實踐中是最常見的。然而，$\ell_\infty$ 通常也表現出穩定 的行為。作者 (Kingma and Ba, 2015) 提出了 AdaMax 並證明了和 $\ell_\infty$ 收斂到更穩定的值。為了避免與 Adam 混用，所以使用 $u_t$<span><span> </span></span>來表示無窮範數約束 <span>$v_t$</span><span><span> </span></span>：</p>
<p>$$u_t = \beta_2^\infty v_{t-1} + (1 - \beta_2^\infty) |g_t|^\infty$$</p>
<p>$$ = \max(\beta_2 \cdot v_{t-1}, |g_t|) $$</p>
<p>替換為 Adam 更新公式$\sqrt{\hat{v}_t} + \epsilon$ <span> </span>和 $u_t$ 得出 AdaMax 更新規則：</p>
<p>$$\theta_{t+1} = \theta_{t} - \dfrac{\eta}{u_t} \hat{m}_t$$</p>
<p>注意 $u_t$ 依靠最大運算，不建議 Adam 中的 <span>$m_t$</span><span><span> </span></span>和 <span>$v_t$</span><span><span> </span></span>偏向零，這就是為什麼不需要針對 <span>$u_t$</span> 計算偏差。好的預設值 $\eta = 0.002$，<span>$\beta_1</span><sub> </sub>= 0.9$ 和 <span>$\beta_2</span> = 0.999$。</p>
<h4>Nadam</h4>
<p>Nadam (Nesterov-accelerated Adaptive Moment Estimation，Nesterov 加速的自適應矩估計)，結合 Adam 和 NAG。為了將 NAG 納入 Adam，需要修改動量項 <span>$m_t$</span>。使用先前符號回顧動量更新規則：</p>
<p>$$g_t = \nabla_{\theta_t}J(\theta_t)$$</p>
<p>$$m_t = \gamma m_{t-1} + \eta g_t$$</p>
<p>$$\theta_{t+1} = \theta_t - m_t $$</p>
<p>J是目標函數，$\gamma$ 是動量衰減項，$\eta$ 是 step size(學習率)，上面的第三個方程式擴展為：</p>
<p>$$\theta_{t+1} = \theta_t - ( \gamma m_{t-1} + \eta g_t)$$</p>
<p>再次證明了動量涉及在前一個動量向量的方向上往前一步和在當前梯度的方向上邁出一步。NAG 然後允許計算梯度之前透過更新動量步長參數使梯度方向上執行更精確的步長。因此，我們只需要修改梯度 $g_t$ 到達 NAG：</p>
<p>$$g_t = \nabla_{\theta_t}J(\theta_t - \gamma m_{t-1})$$</p>
<p>$$m_t = \gamma m_{t-1} + \eta g_t$$</p>
<p>$$\theta_{t+1} = \theta_t - m_t$$</p>
<p>Dozat 建議修改 NAG：一次用於更新梯度 <span>$g_t$</span> 第二次更新參數 $\theta_{t+1}$，直接應用先前的動量向量來更新當前參數：</p>
<p>$$g_t = \nabla_{\theta_t}J(\theta_t)$$</p>
<p>$$m_t = \gamma m_{t-1} + \eta g_t$$</p>
<p>$$\theta_{t+1} = \theta_t - (\gamma m_t + \eta g_t)$$</p>
<p>為了將 Nesterov 動量添加到 Adam，可以類似地用當前動量向量替換以前的動量向量。回想一下 Adam 更新規則 如下：</p>
<p>$$m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t$$</p>
<p>$$\hat{m}_t = \frac{m_t}{1 - \beta^t_1}$$</p>
<p>$$\theta_{t+1} = \theta_{t} - \frac{\eta}{\sqrt{\hat{v}_t} + \epsilon} \hat{m}_t $$</p>
<p>用定義拓展第二個方程式：</p>
<p>$$\theta_{t+1} = \theta_{t} - \frac{\eta}{\sqrt{\hat{v}_t} + \epsilon} (\frac{\beta_1 m_{t-1}}{1 - \beta^t_1} + \frac{(1 - \beta_1) g_t}{1 - \beta^t_1})$$</p>
<p>注意 $\frac{\beta_1 m_{t-1}}{1 - \beta^t_1}$ 只是前一個的 time step 的動量向量的偏差來校正評估。因此，可以將其替換為 $\hat{m}_{t-1}$：</p>
<p>$$\theta_{t+1} = \theta_{t} - \frac{\eta}{\sqrt{\hat{v}_t} + \epsilon} (\beta_1 \hat{m}_{t-1} + \frac{(1 - \beta_1) g_t}{1 - \beta^t_1})$$</p>
<p>為簡化，因為無論如何將在下一步中替換分母，所以忽略了分母 $1 - \beta^t_1$。該方程式再次看起來和上面擴展的動量更 新規則非常相似。可以像以前一樣添加 Nesterov 動量，方法是用當前動量向量偏差校正後的評估值替換前一時間步 長的動量向量偏差校正後的評估值，這為我們提供了 Nadam 更新規則：</p>
<p>$$\theta_{t+1} = \theta_{t} - \frac{\eta}{\sqrt{\hat{v}_t} + \epsilon} (\beta_1 \hat{m}_t + \frac{(1 - \beta_1) g_t}{1 - \beta^t_1})$$</p>
<h4>AMSGrad</h4>
<p>Reddi 等（2018）。正式化了這個問題，並指出了泛化行為不佳的原因：將過去梯度平方的指數移動平均值作為自適應學習率方法。雖然引入指數平均值的動機很充分：應防止學習率隨著訓練的進行而變得無限小；但這也是 Adagrad 算法的關鍵缺陷。在其他情況下，短期記憶的梯度成為障礙。</p>
<p>在 Adam 收斂到次優解的環境中，已經觀察到一些小型批次提供了較大且信息豐富的梯度，但是這些小型批次很少出現，因此指數平均會減小其影響，從而導致收斂性較差。作者 (資料來源的作者) 提供了一個簡單的凸型優化問題的例子，其中 Adam 可以觀察到相同的行為。AMSGrad算法是為了解決此問題，這算法使用了過去梯度平方的最大值 <span>$v_t$</span><sub> </sub>而不是指數平均值來更新參數。<span>$v_t$</span><sub> </sub>的定義與先前的 Adam 相同：</p>
<p>$$v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2$$</p>
<p>而不是直接使用 $v_t$(或其偏差更正的版本 vˆt），如果現在使用以前值的大於現在的值：</p>
<p>$$\hat{v}_t = \text{max}(\hat{v}_{t-1}, v_t)$$</p>
<p>這方式 AMSGrad 不會增加步長 (step size)，從而避免了 Adam 遇到的問題。為了簡化，AMSGrad 去除了 Adam 的去偏差 (debias) 步驟。可以看到完整的 AMSGrad 更新，沒有經過偏差校正的估計：</p>
<p>$$m_t = \beta_1 m_{t-1} + (1 - \beta_1) g_t $$</p>
<p>$$v_t = \beta_2 v_{t-1} + (1 - \beta_2) g_t^2$$</p>
<p>$$\hat{v}_t = \text{max}(\hat{v}_{t-1}, v_t)$$</p>
<p>$$\theta_{t+1} = \theta_{t} - \frac{\eta}{\sqrt{\hat{v}_t} + \epsilon} m_t$$</p>
<p>在小型數據集和 CIFAR-10 上，與 Adam 相比，性能有所提高。但是，其他實驗顯示其性能與 Adam 相近或更 差。在實際運用，AMSGrad 是否能勝過 Adam，還有待觀察。</p>
<h4>Gradient noise</h4>
<p>增加 noise 跟隨高斯分布 $N(0, \sigma^2_t)$ 對每個梯度更新：</p>
<p>$$g_{t, i} = g_{t, i} + N(0, \sigma^2_t)$$</p>
<p>根據排定時間對差異計算：</p>
<p>$$\sigma^2_t = \frac{\eta}{(1 + t)^\gamma}$$</p>
<p>添加這種 noise 對不良初始化的網絡可使其強化，並有助於訓練特別深且復雜的網絡。他們懷疑增加的噪聲使模型 有更多的機會逃脫並找到新的局部極小值，這對於更深的模型而言更常見。</p>
<h1>程式</h1>
<h4>pygame</h4>
<p>訓練用的Pygame程式：</p>
<p><a href="https://github.com/s40723150/pygame_airhockey">https://github.com/s40723150/pygame_airhockey</a></p>
<p><a href="https://github.com/mdecourse/4072pj1/tree/master/40723150/pygame">https://github.com/mdecourse/4072pj1/tree/master/40723150/pygame</a></p>
<p></p>
<h2>RL-Pong Game</h2>
<pre class="brush:html;auto-links:false;toolbar:false" contenteditable="false">import pygame
import random , sys
from pygame.locals import *
import numpy as np
from collections import deque
import tensorflow as tf  # http://blog.topspeedsnail.com/archives/10116
import cv2  # http://blog.topspeedsnail.com/archives/4755

tf.compat.v1.disable_eager_execution()

BLACK = (0, 0, 0)
WHITE = (255, 255, 255)

SCREEN_SIZE = [320, 400]
BAR_SIZE = [50, 5]
BAR2_SIZE = [50,5]
BALL_SIZE = [15, 15]

# 神經網絡的輸出
MOVE_STAY = [1, 0, 0]
MOVE_LEFT = [0, 1, 0]
MOVE_RIGHT = [0, 0, 1]


class Game(object):
    def __init__(self):
        pygame.init()
        self.clock = pygame.time.Clock()
        self.screen = pygame.display.set_mode(SCREEN_SIZE)
        pygame.display.set_caption('Simple Game')

        self.ball_pos_x = SCREEN_SIZE[0] // 2 - BALL_SIZE[0] / 2
        self.ball_pos_y = SCREEN_SIZE[1] // 2 - BALL_SIZE[1] / 2

        self.ball_dir_x = -1  # -1 = left 1 = right
        self.ball_dir_y = -1  # -1 = up   1 = down
        self.ball_pos = pygame.Rect(self.ball_pos_x, self.ball_pos_y, BALL_SIZE[0], BALL_SIZE[1])

        self.bar_pos_x = SCREEN_SIZE[0] // 2 - BAR_SIZE[0] // 2
        self.bar_pos = pygame.Rect(self.bar_pos_x, SCREEN_SIZE[1] - BAR_SIZE[1]-5, BAR_SIZE[0], BAR_SIZE[1])

        self.bar2_pos_x = SCREEN_SIZE[0] // 2 - BAR_SIZE[0] // 2
        self.bar2_pos = pygame.Rect(self.bar_pos_x, 5, BAR_SIZE[0], BAR_SIZE[1])
        self.bar2_speed = 7


    # action是MOVE_STAY、MOVE_LEFT、MOVE_RIGHT
    # ai控制棒子左右移動；返回遊戲界面像素數和對應的獎勵。(像素-&gt;獎勵-&gt;強化棒子往獎勵高的方向移動)


    def step(self, action):

        if action == MOVE_LEFT:
            self.bar_pos_x = self.bar_pos_x - 2
        elif action == MOVE_RIGHT:
            self.bar_pos_x = self.bar_pos_x + 2
        else:
            pass
        if self.bar_pos_x &lt; 0:
            self.bar_pos_x = 0
        if self.bar_pos_x &gt; SCREEN_SIZE[0] - BAR_SIZE[0]:
            self.bar_pos_x = SCREEN_SIZE[0] - BAR_SIZE[0]

        if  self.bar2_pos.left &lt; self.ball_pos.x:
            self.bar2_pos.x += self.bar2_speed
        if  self.bar2_pos.right &gt; self.ball_pos.x:
            self.bar2_pos.x -= self.bar2_speed

        if  self.bar2_pos.left &lt;= 0:
            self.bar2_pos.left = 0
        if  self.bar2_pos.right &gt;= SCREEN_SIZE[0]:
            self.bar2_pos.right = SCREEN_SIZE[0]

        self.screen.fill(BLACK)
        self.bar_pos.left = self.bar_pos_x
        pygame.draw.rect(self.screen, WHITE, self.bar_pos)
        pygame.draw.rect(self.screen, WHITE, self.bar2_pos)
        pygame.draw.rect(self.screen, (255, 0, 0), Rect((5, 5), (310, 390)), 2)
        pygame.draw.line(self.screen, (255, 0, 0), (7, 195), (313, 195), 2)
        pygame.draw.circle(self.screen, (255, 0, 0), (160, 195), 50, 2)

        self.ball_pos.left += self.ball_dir_x * 2
        self.ball_pos.bottom += self.ball_dir_y * 3
        pygame.draw.rect(self.screen, WHITE, self.ball_pos)

        if self.ball_pos.top &lt;= 0 or self.ball_pos.bottom &gt;= (SCREEN_SIZE[1] - BAR_SIZE[1] + 1):
            self.ball_dir_y = self.ball_dir_y * -1
        if self.ball_pos.left &lt;= 0 or self.ball_pos.right &gt;= (SCREEN_SIZE[0]):
            self.ball_dir_x = self.ball_dir_x * -1

        reward = 0
        if self.bar_pos.top &lt;= self.ball_pos.bottom and (
                self.bar_pos.left &lt; self.ball_pos.right and self.bar_pos.right &gt; self.ball_pos.left):
            reward = 1  # 擊中獎勵
        elif self.bar_pos.top &lt;= self.ball_pos.bottom and (
                self.bar_pos.left &gt; self.ball_pos.right or self.bar_pos.right &lt; self.ball_pos.left):
            reward = -1  # 沒擊中懲罰

        # 獲得遊戲界面像素
        screen_image = pygame.surfarray.array3d(pygame.display.get_surface())
        pygame.display.update()
        # 返回遊戲界面像素和對應的獎勵
        return reward, screen_image


# learning_rate
LEARNING_RATE = 0.99
# 更新梯度
INITIAL_EPSILON = 1.0
FINAL_EPSILON = 0.05
# 測試觀測次數
EXPLORE = 500000
OBSERVE = 50000
# 存儲過往經驗大小
REPLAY_MEMORY = 500000

BATCH = 100

output = 3  # 輸出層神經元數。代表3種操作-MOVE_STAY:[1, 0, 0]  MOVE_LEFT:[0, 1, 0]  MOVE_RIGHT:[0, 0, 1]
input_image = tf.compat.v1.placeholder("float", [None, 80, 100, 4])  # 遊戲像素
action = tf.compat.v1.placeholder("float", [None, output])  # 操作


# 定義CNN-卷積神經網絡 參考:http://blog.topspeedsnail.com/archives/10451
def convolutional_neural_network(input_image):
    weights = {'w_conv1': tf.Variable(tf.zeros([8, 8, 4, 32])),
               'w_conv2': tf.Variable(tf.zeros([4, 4, 32, 64])),
               'w_conv3': tf.Variable(tf.zeros([3, 3, 64, 64])),
               'w_fc4': tf.Variable(tf.zeros([3456, 784])),
               'w_out': tf.Variable(tf.zeros([784, output]))}

    biases = {'b_conv1': tf.Variable(tf.zeros([32])),
              'b_conv2': tf.Variable(tf.zeros([64])),
              'b_conv3': tf.Variable(tf.zeros([64])),
              'b_fc4': tf.Variable(tf.zeros([784])),
              'b_out': tf.Variable(tf.zeros([output]))}

    conv1 = tf.nn.relu(
        tf.nn.conv2d(input_image, weights['w_conv1'], strides=[1, 4, 4, 1], padding="VALID") + biases['b_conv1'])
    conv2 = tf.nn.relu(
        tf.nn.conv2d(conv1, weights['w_conv2'], strides=[1, 2, 2, 1], padding="VALID") + biases['b_conv2'])
    conv3 = tf.nn.relu(
        tf.nn.conv2d(conv2, weights['w_conv3'], strides=[1, 1, 1, 1], padding="VALID") + biases['b_conv3'])
    conv3_flat = tf.reshape(conv3, [-1, 3456])
    fc4 = tf.nn.relu(tf.matmul(conv3_flat, weights['w_fc4']) + biases['b_fc4'])

    output_layer = tf.matmul(fc4, weights['w_out']) + biases['b_out']
    return output_layer


# 深度強化學習入門: https://www.nervanasys.com/demystifying-deep-reinforcement-learning/
# 訓練神經網絡
def train_neural_network(input_image):
    predict_action = convolutional_neural_network(input_image)

    argmax = tf.compat.v1.placeholder("float", [None, output])
    gt = tf.compat.v1.placeholder("float", [None])

    action = tf.reduce_sum(tf.multiply(predict_action, argmax), axis=1)
    cost = tf.reduce_mean(tf.square(action - gt))
    optimizer = tf.compat.v1.train.AdamOptimizer(1e-6).minimize(cost)

    game = Game()
    D = deque()

    _, image = game.step(MOVE_STAY)
    # 轉換爲灰度值
    image = cv2.cvtColor(cv2.resize(image, (100, 80)), cv2.COLOR_BGR2GRAY)
    # 轉換爲二值
    ret, image = cv2.threshold(image, 1, 255, cv2.THRESH_BINARY)
    input_image_data = np.stack((image, image, image, image), axis=2)

    with tf.compat.v1.Session() as sess:
        sess.run(tf.compat.v1.initialize_all_variables())

        saver = tf.compat.v1.train.Saver()

        n = 0
        epsilon = INITIAL_EPSILON
        while True:
            for event in pygame.event.get():
             if event.type == pygame.QUIT:
                 pygame.quit()
                 sys.exit()


            action_t = predict_action.eval(feed_dict={input_image: [input_image_data]})[0]

            argmax_t = np.zeros([output], dtype=np.int)
            if (random.random() &lt;= INITIAL_EPSILON):
                maxIndex = random.randrange(output)
            else:
                maxIndex = np.argmax(action_t)
            argmax_t[maxIndex] = 1
            if epsilon &gt; FINAL_EPSILON:
                epsilon -= (INITIAL_EPSILON - FINAL_EPSILON) / EXPLORE

            # for event in pygame.event.get():  macOS需要事件循環，否則白屏
            #	if event.type == QUIT:
            #		pygame.quit()
            #		sys.exit()
            reward, image = game.step(list(argmax_t))

            image = cv2.cvtColor(cv2.resize(image, (100, 80)), cv2.COLOR_BGR2GRAY)
            ret, image = cv2.threshold(image, 1, 255, cv2.THRESH_BINARY)
            image = np.reshape(image, (80, 100, 1))
            input_image_data1 = np.append(image, input_image_data[:, :, 0:3], axis=2)

            D.append((input_image_data, argmax_t, reward, input_image_data1))

            if len(D) &gt; REPLAY_MEMORY:
                D.popleft()

            if n &gt; OBSERVE:
                minibatch = random.sample(D, BATCH)
                input_image_data_batch = [d[0] for d in minibatch]
                argmax_batch = [d[1] for d in minibatch]
                reward_batch = [d[2] for d in minibatch]
                input_image_data1_batch = [d[3] for d in minibatch]

                gt_batch = []

                out_batch = predict_action.eval(feed_dict={input_image: input_image_data1_batch})

                for i in range(0, len(minibatch)):
                    gt_batch.append(reward_batch[i] + LEARNING_RATE * np.max(out_batch[i]))

                optimizer.run(feed_dict={gt: gt_batch, argmax: argmax_batch, input_image: input_image_data_batch})

            input_image_data = input_image_data1
            n = n + 1

            if n % 10000 == 0:
                saver.save(sess, 'game.cpk', global_step=n)  # 保存模型

            print(n, "epsilon:", epsilon, " ", "action:", maxIndex, " ", "reward:", reward)


train_neural_network(input_image)</pre>
<p></p>
<h1>Ref</h1>
<h2>Flutter</h2>
<p>Flutter 與 Android sdk 版本差異問題解決: <a href="https://stackoverflow.com/questions/60440509/android-command-line-tools-sdkmanager-always-shows-warning-could-not-create-se/61613986#61613986">https://stackoverflow.com/questions/60440509/android-command-line-tools-sdkmanager-always-shows-warning-could-not-create-se/61613986#61613986</a></p>
<p>Flask 與 ML 系統在後端, Flutter 作為前端</p>
<p><a href="https://medium.com/analytics-vidhya/deploy-ml-models-using-flask-as-rest-api-and-access-via-flutter-app-7ce63d5c1f3b">https://medium.com/analytics-vidhya/deploy-ml-models-using-flask-as-rest-api-and-access-via-flutter-app-7ce63d5c1f3b</a></p>
<p><a href="https://medium.com/@pyzimos/flutter-chatbot-with-python-flask-backend-heroku-deployment-706baafbb8f1">https://medium.com/@pyzimos/flutter-chatbot-with-python-flask-backend-heroku-deployment-706baafbb8f1</a></p>
<p><a href="https://github.com/SHARONZACHARIA/Deploy-ML-model">https://github.com/SHARONZACHARIA/Deploy-ML-model</a></p>
<p><a href="https://github.com/tonynguyen72/Flask_API_Flutter">https://github.com/tonynguyen72/Flask_API_Flutter</a></p>
<p><a href="https://github.com/mohammedhashim44/Flutter-Flask-Login">https://github.com/mohammedhashim44/Flutter-Flask-Login</a></p>
<h2>CMSiMDE</h2>
<p><a href="https://websitesetup.org/bootstrap-tutorial-for-beginners/">https://websitesetup.org/bootstrap-tutorial-for-beginners/</a></p>
<p><a href="https://colorlib.com/wp/themes/travelify/">https://colorlib.com/wp/themes/travelify/</a> </p>
<p><a href="https://github.com/puikinsh/travelify">https://github.com/puikinsh/travelify</a></p>
<p></p>
<h1>Q&amp;A</h1>
<p><a href="/content/CMSiMDE.html">cmsimde</a></p>
<p><a href="/content/FFMPEG.html">ffmpeg</a></p><h2>cmsimde</h2>
<p>Q：啟用cmsimde的MathJax的功能遇到文章使用括號補充說明的內容被誤當成latex的語法轉換。</p>
<p>A：格式轉換原始定義成"("和")"，所以出現誤換的問題</p>
<p>原程式：</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">&lt;script&gt;
  MathJax = {
    tex: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
  };
  &lt;/script&gt;
  &lt;script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"&gt;&lt;/script&gt;</pre>
<p>修正後將<span>"("和")"換成"$"，就解決誤換問題</span></p>
<p>修正後：</p>
<pre class="brush:js;auto-links:false;toolbar:false" contenteditable="false">&lt;script&gt;
  MathJax = {
    tex: {inlineMath : [ ['$','$'], ["\\$","\\$"] ]}
  };
  &lt;/script&gt;
  &lt;script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"&gt;&lt;/script&gt; </pre>
<h2>ffmpeg</h2>
<p>Q：錄製訓練過程的程式讀不到ffmpeg。</p>
<p><img alt="" height="200" src="/images/Q_ffmpeg.png" width="696"/></p>
<p style="text-align: center;">圖1.程式讀不到ffmpeg</p>
<p>A：需要在作業系統中安裝ffmpeg</p>
<ol>
<li>下載、解壓縮<br/>先到官網 <a href="https://ffmpeg.org/download.html">https://ffmpeg.org/download.html</a> 下載 "<a href="https://www.gyan.dev/ffmpeg/builds/">Windows builds from gyan.dev</a>"，下載<a href="https://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full.7z">https://www.gyan.dev/ffmpeg/builds/ffmpeg-git-full.7z</a>，解壓縮重新命名成"ffmpeg"並放到C槽目錄下(C:\ffmpeg)。</li>
<li>環境設定(windows10 20H2 及 2004版本)<br/>開啟"設定"→"系統"→左方"關於"選項→右側"進階系統設定"→"環境變數"(圖2.)→選取"Path"，編輯(圖3.)→"新增"，增加一個環境變數，給定內容為:"C:\ffmpeg\bin"，"確定"(圖4.)→"確定"→"確定</li>
</ol>
<p style="text-align: center;"><img alt="圖2.進階系統設定" caption="false" height="300" src="/images/Q_ffmpeg-2.png" width="278"/><br/>圖2.進階系統設定<br/><img caption="false" height="300" src="/images/Q_ffmpeg-3.png" style="display: block; margin-left: auto; margin-right: auto;" width="326"/>圖3.環境變數<br/><img caption="false" height="300" src="/images/Q_ffmpeg-4.png" style="display: block; margin-left: auto; margin-right: auto;" width="324"/>圖4.編輯環境變數</p>
<ul>
<li style="text-align: left;">測試<br/>開啟命令字元(win+R，輸入"cmd")，執行"ffmpeg"(圖5.)<br/><img alt="" height="300" src="/images/Q_ffmpeg-5.png" width="575"/></li>
</ul>
<p style="text-align: center;">圖5.ffmpeg成功執行</p>
<div id="gtx-trans" style="position: absolute; left: 39px; top: 1750.38px;">
<div class="gtx-trans-icon"></div>
</div>